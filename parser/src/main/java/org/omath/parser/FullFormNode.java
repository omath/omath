/* Generated By:JJTree: Do not edit this line. ASTFullForm.java */


package org.omath.parser;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import net.tqft.iterables.Iterables;

public class FullFormNode implements Node {
  
	protected Node parent;
	protected List<Node> children;
	protected int id;
	protected SyntaxParser parser;
	
	public Node head;
	public boolean m_reverseChildren =false;
	public Integer headLocation;

	public boolean replaceWithChild = false;
	
	//firstchild is used when you want to clone one of the children.
	//if firstChild is not null, all operations go through it.

  
	public FullFormNode(int i) {
		id = i;
		children = new ArrayList<Node>();
		head=null;
		headLocation=null;
	}
	
	public FullFormNode(SyntaxParser p, int id) {
	  this(id);
	  parser = p;
	    
	}
  
	public int jjtFindChild(Node n){
		assert(!replaceWithChild);
		return children.indexOf(n);
	  }
	  
	
	
	//in these two operation we don't ask the child for it's parent, because that
	//us. so even is firstChild is not null, we still return our own parent.
	public Node jjtGetParent() { 
		assert(!replaceWithChild); 
		return parent; 
	}
	
	public void jjtSetParent(Node n) { 
		parent = n; 
		if(replaceWithChild){
			replaceByOnlyChild();
		}
	}

	  public void jjtAddChild(Node n, int i) {
			assert(!replaceWithChild);

		  while(i>=children.size()){
			  children.add(children.size(),null);
		  }
		  children.set(i,n);
	  }

	  public Node jjtRemoveChild(int i){
			assert(!replaceWithChild);

		  return children.remove(i);
	  }

	  public Node jjtGetChild(int i) {
			assert(!replaceWithChild);

	    return children.get(i);
	  }

	  public int jjtGetNumChildren() {
			assert(!replaceWithChild);

	    return children.size();
	  }
  
	
	public static FullFormNode CREATEFULLFORM(String head, Node... nodes){
	  FullFormNode ret = new FullFormNode(SyntaxParserTreeConstants.JJTFULLFORM);
	  
	  ret.setHead(head); 

	  int i=0;
	  for(Node node : nodes){
		  node.jjtSetParent(ret);
		  ret.jjtAddChild(node,i);
		  i++;
	  }
	  
	  return ret;
  }
  
  
  public Node getHead() {
		assert(!replaceWithChild);

	return head;
}
	
public void setHead(String head){
	assert(!replaceWithChild);

	ASTMyID node = new ASTMyID(SyntaxParserTreeConstants.JJTMYID);
	node.setValue(head);
	this.head=node;
}

public void setHead(Node head) {
	assert(!replaceWithChild);
	this.head = head;
}

public boolean hasHead(){
	assert(!replaceWithChild);

	return head!=null;
}

public void setHeadLocation(int i){
	assert(!replaceWithChild);
	this.headLocation=i;
}

  
protected Node popChild(){
	assert(!replaceWithChild);
	return children.remove(children.size()-1);
}


public void jjtOpen() {
	assert(!replaceWithChild);
}


public void jjtClose() {
	assert(!replaceWithChild);
	//Notice that headLocation is looked at before the (optional) reversing of the 
	//children. currently I don't have a use that both takes the head form the children
	//and needs to reverse the remaining children...if you do, please change this comment
	//and explain what you do (and why...)
	
	if(!hasHead()&&headLocation!=null){
		if(headLocation<0)
			headLocation = children.size()+headLocation;
		head = jjtRemoveChild(headLocation);
	}
	if(!hasHead()) throw new Error("You must set the Head or the HeadLocation of a FullFormNode");

	if(m_reverseChildren){
		Collections.reverse(children); 
		m_reverseChildren=false;
	}
}

public void reverseChildren(){
	assert(!replaceWithChild);
		m_reverseChildren=true;
}

public String toString() {
	assert(!replaceWithChild);

  	StringBuffer string = new StringBuffer("");
	string.append( preChildren());
	
	if(getChildren().size()>0)
		string.append(jjtGetChild(0).toString());

	for (Node child:Iterables.rest(children)){
			string.append(betweenChildren());
			if (child != null) {
				string.append(child.toString());
			}
	}

	string.append(postChildren());

	return string.toString();
}


public String preChildren() {
	assert(!replaceWithChild);
	return getHead().toString() + m_preChildren;
}

public String betweenChildren() {
	assert(!replaceWithChild);

	return ", ";
}

public String postChildren() {	
	assert(!replaceWithChild);
	return m_postChildren;
}

protected String m_preChildren="[";
protected String m_postChildren="]";


public List<Node> getChildren() {
	assert(!replaceWithChild);
	
	return Collections.unmodifiableList(children);
}


protected void replaceByOnlyChild(){
	replaceWithChild=false;//just so all the following operations will work...
	assert(jjtGetNumChildren()==1);
	if(parent!=null){
		Node child = jjtGetChild(0);
		int locationInParent = parent.getChildren().indexOf(this);
		parent.jjtAddChild(child, locationInParent);
		child.jjtSetParent(parent);		
	}	
	replaceWithChild=true;
	
}

}

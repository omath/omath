/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /Users/scott/projects/omath/parser/java-source/org/omath/parser/SyntaxParser.jj */
/*@egen*/options
{
	STATIC = false;                                             
}




PARSER_BEGIN(SyntaxParser)

package org.omath.parser;

import java.io.StringReader;

import org.omath.parser.ParseException;
import org.omath.parser.Node;
import org.omath.parser.SyntaxParser;
import org.omath.parser.TokenMgrError;

public class SyntaxParser/*@bgen(jjtree)*/implements SyntaxParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSyntaxParserState jjtree = new JJTSyntaxParserState();

/*@egen*/

	public static Node parseSyntaxString(String input)
			throws org.omath.parser.ParseException {
		SyntaxParser parser = new SyntaxParser(new StringReader(input));
		try {
			return parser.totalExpression().jjtGetChild(0);
		} catch (ParseException e) {
			throw wrappedException(e, input);
		} catch (TokenMgrError e) {
			throw wrappedException(e, input);			
		}
	}
	
	private static ParseException wrappedException(Throwable e, String input) {
		String message = "While attempting to parse ";
		if (input.length() > 500) {
			message += "a very long string:\n";
		} else {
			message += "\n+++\n" + input + "\n+++\n";
		}
		return new ParseException(message + e.getMessage(), e);
	}
}


PARSER_END(SyntaxParser)


TOKEN_MGR_DECLS : {

    int commentNestingDepth ; 
	
}

	/*
	 * we only have one kind of special token, so in the code, I will assume that if
	 * the specialToken field isn't null, it is of kind WHITESPACE. if this changes, you'll
	 * need to add the extra check (mostly related to the patternExpression)
	 */
	 
SPECIAL_TOKEN:
{
  <WHITESPACE: " " | "\t" | "\n" | "\r">
}


// Go into the IN_COMMENT state when an "(*" is encountered
SKIP : {

    "(*" {commentNestingDepth=1;} : IN_COMMENT } 
  
 < IN_COMMENT >  SKIP : {  
// While in the comment "*)" reduces the nesting count
// if nesting count goes down to zero, switch out of this 
 	"*)" 					{commentNestingDepth -= 1;
    						 SwitchTo( commentNestingDepth==0 ? DEFAULT : IN_COMMENT ) ; } 
// if encounter another "*)", increase nesting count.
|	"(*"					{commentNestingDepth++;}

// When any other character is seen in the IN_COMMENT state, skip it.
|    <  ~[] > 
} 

    
//END of code from idevelopment.


// a double quotes changes the lexical state to IN_STRING_LITERAL
MORE : {
    "\"": IN_STRING_LITERAL } 

//in this LEX state, a " pops you back out to default and returns the string as a token 
< IN_STRING_LITERAL > TOKEN : {
   <STRING_LITERAL:"\"">: DEFAULT 
} 

//escaped quotes are OK, but don't escape with an escaped backslash...
< IN_STRING_LITERAL > MORE : {
   < "\\\"" > 
 | < "\\\\" >
  
   } 
 // anything else is also ok.
< IN_STRING_LITERAL > MORE : {
   <  ~[] > } 


         

//TOKEN : 
//{
//	<#Omega: "\\[Omega]">
//|	<#Alpha: "\\[Alpha]">
//|	<#Beta:  "\\[Beta]">
	
//|<#SPECIALCHAR: 
//	<Alpha>
//|	<Beta>
//|	<Omega>
//>
//}   


TOKEN :
{
      <#ImaginaryI: "\\[ImaginaryI]">
|      <#Alpha: "\\[Alpha]">
|      <#Beta: "\\[Beta]">
|      <#Gamma: "\\[Gamma]">
|      <#Delta: "\\[Delta]">
|      <#Epsilon: "\\[Epsilon]">
|      <#CurlyEpsilon: "\\[CurlyEpsilon]">
|      <#Zeta: "\\[Zeta]">
|      <#Eta: "\\[Eta]">
|      <#Theta: "\\[Theta]">
|      <#CurlyTheta: "\\[CurlyTheta]">
|      <#Iota: "\\[Iota]">
|      <#Kappa: "\\[Kappa]">
|      <#CurlyKappa: "\\[CurlyKappa]">
|      <#Lambda: "\\[Lambda]">
|      <#Mu: "\\[Mu]">
|      <#Nu: "\\[Nu]">
|      <#Xi: "\\[Xi]">
|      <#Omicron: "\\[Omicron]">
|      <#Pi: "\\[Pi]">
|      <#CurlyPi: "\\[CurlyPi]">
|      <#Rho: "\\[Rho]">
|      <#CurlyRho: "\\[CurlyRho]">
|      <#Sigma: "\\[Sigma]">
|      <#FinalSigma: "\\[FinalSigma]">
|      <#Tau: "\\[Tau]">
|      <#Upsilon: "\\[Upsilon]">
|      <#Phi: "\\[Phi]">
|      <#CurlyPhi: "\\[CurlyPhi]">
|      <#Chi: "\\[Chi]">
|      <#Psi: "\\[Psi]">
|      <#Omega: "\\[Omega]">
|      <#Digamma: "\\[Digamma]">
|      <#Koppa: "\\[Koppa]">
|      <#Stigma: "\\[Stigma]">
|      <#Sampi: "\\[Sampi]">
|      <#CapitalAlpha: "\\[CapitalAlpha]">
|      <#CapitalBeta: "\\[CapitalBeta]">
|      <#CapitalGamma: "\\[CapitalGamma]">
|      <#CapitalDelta: "\\[CapitalDelta]">
|      <#CapitalEpsilon: "\\[CapitalEpsilon]">
|      <#CapitalZeta: "\\[CapitalZeta]">
|      <#CapitalEta: "\\[CapitalEta]">
|      <#CapitalTheta: "\\[CapitalTheta]">
|      <#CapitalIota: "\\[CapitalIota]">
|      <#CapitalKappa: "\\[CapitalKappa]">
|      <#CapitalLambda: "\\[CapitalLambda]">
|      <#CapitalMu: "\\[CapitalMu]">
|      <#CapitalNu: "\\[CapitalNu]">
|      <#CapitalXi: "\\[CapitalXi]">
|      <#CapitalOmicron: "\\[CapitalOmicron]">
|      <#CapitalPi: "\\[CapitalPi]">
|      <#CapitalRho: "\\[CapitalRho]">
|      <#CapitalSigma: "\\[CapitalSigma]">
|      <#CapitalTau: "\\[CapitalTau]">
|      <#CapitalUpsilon: "\\[CapitalUpsilon]">
|      <#CurlyCapitalUpsilon: "\\[CurlyCapitalUpsilon]">
|      <#CapitalPhi: "\\[CapitalPhi]">
|      <#CapitalChi: "\\[CapitalChi]">
|      <#CapitalPsi: "\\[CapitalPsi]">
|      <#CapitalOmega: "\\[CapitalOmega]">
|      <#CapitalDigamma: "\\[CapitalDigamma]">
|      <#CapitalKoppa: "\\[CapitalKoppa]">
|      <#CapitalStigma: "\\[CapitalStigma]">
|      <#CapitalSampi: "\\[CapitalSampi]">
|<#SPECIALCHAR:
      <ImaginaryI>
|      <Alpha>
|      <Beta>
|      <Gamma>
|      <Delta>
|      <Epsilon>
|      <CurlyEpsilon>
|      <Zeta>
|      <Eta>
|      <Theta>
|      <CurlyTheta>
|      <Iota>
|      <Kappa>
|      <CurlyKappa>
|      <Lambda>
|      <Mu>
|      <Nu>
|      <Xi>
|      <Omicron>
|      <Pi>
|      <CurlyPi>
|      <Rho>
|      <CurlyRho>
|      <Sigma>
|      <FinalSigma>
|      <Tau>
|      <Upsilon>
|      <Phi>
|      <CurlyPhi>
|      <Chi>
|      <Psi>
|      <Omega>
|      <Digamma>
|      <Koppa>
|      <Stigma>
|      <Sampi>
|      <CapitalAlpha>
|      <CapitalBeta>
|      <CapitalGamma>
|      <CapitalDelta>
|      <CapitalEpsilon>
|      <CapitalZeta>
|      <CapitalEta>
|      <CapitalTheta>
|      <CapitalIota>
|      <CapitalKappa>
|      <CapitalLambda>
|      <CapitalMu>
|      <CapitalNu>
|      <CapitalXi>
|      <CapitalOmicron>
|      <CapitalPi>
|      <CapitalRho>
|      <CapitalSigma>
|      <CapitalTau>
|      <CapitalUpsilon>
|      <CurlyCapitalUpsilon>
|      <CapitalPhi>
|      <CapitalChi>
|      <CapitalPsi>
|      <CapitalOmega>
|      <CapitalDigamma>
|      <CapitalKoppa>
|      <CapitalStigma>
|      <CapitalSampi>>
}

TOKEN :
{
  <FALSE: []>
| <PERIOD: ".">
|  <EOL: "\n" | "\r" | "\r\n" > 
| <#DIGIT: ["0"-"9"]>
| <NONNEGATIVEINTEGER: (<DIGIT>)+>
| <#LETTER: ["a"-"z","A"-"Z","$","`"]>
| <#GENLETTER: <LETTER>|<SPECIALCHAR>>
| <#ALPHANUMERIC: <GENLETTER>|<DIGIT>>
| <SYMBOL: <GENLETTER>(<ALPHANUMERIC>)*>
| <LBRACKET: "[">
| <RBRACKET: "]">
| <TwoLBRACKETS: "[[">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <COMMA: ",">
| <BLANK: "_">
| <BLANKSEQUENCE: "__">
| <BLANKNULLSEQUENCE: "___">
| <HASH: "#">
| <HASHHASH: "##">
| <PERCENT: "%">
| <QUESTIONMARK: "?">
| <QUESTIONMARK2: "??">

| <Factorial2: "!!">
| <Apply: "@@">
| <GreaterEqual: ">=">
| <StringExpression: "~~">
| <RepeatedNull: "...">
| <StringJoin: "<>">
| <Or: "||">
| <LessEqual: "<=">
| <Map: "/@">
| <SetDelayed: ":=">
| <RuleDelayed: ":>">
| <DeepApply: "@@@">
| <MessageName: "::">
| <Unequal: "!=">
| <Not: "!">
| <SameQ: "===">
| <UpSet: "^=">
| <Repeated: "..">
| <Function: "&">
| <Colon: "\\[Colon]">
| <PLUS: "+">
| <TIMES: "*">
| <MINUS: "-">
| <DIVIDE: "/">
| <CirclePlus: "\\[CirclePlus]">
| <CompoundExpression: ";">
| <Optional: ":">
| <Set: "=">
| <Less: "<">
| <Greater: ">">
| <TimesBy: "*=">
| <ReplaceRepeated: "//.">
| <Equal: "==">
| <And: "&&">
| <At: "@">
| <Unset: "=.">
| <UpSetDelayed: "^:=">
| <Power: "^">
| <SlashSlash: "//">
| <ReplaceAll: "/.">
| <ApplyAll: "//@">
| <PreDecrement: "--">
| <UnsameQ: "=!=">
| <PreIncrement: "++">
| <DivideBy: "/=">
| <Condition: "/;">
| <Tag: "/:">
| <SubtractFrom: "-=">
| <Rule: "->">
| <Alternatives: "|">
| <AddTo: "+=">
| <Tilde: "~">

}
FullFormNode totalExpression()      :{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
try {
/*@egen*/

LOOKAHEAD(1)
	<QUESTIONMARK> ( symbolExpression() 
					|literalString()   )	
|	
	<QUESTIONMARK2> ( symbolExpression() 
					| literalString()   )	

|   ([syntaxExpression()] (<EOL>|<EOF>) )
	{jjtn000.setHead("START");}/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{	return (FullFormNode)jjtree.peekNode();}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void syntaxExpression() :{}
{
	level300()
}

void False(): {} {
	<FALSE>
	
}


void looserPrefix300():
{}
{
	False()
}

//Start of automatic level creation

/*
 * Stub Function for flat operator with possible postfix
 * (build to accomodate behavior of ; (CompoundExpression) 
 * a;b  --> CompoundExpression[a, b]
 * a;b; --> CompoundExpression[a, b, Null]
 * a;;b; --> CompoundExpression[a, Null, b, Null]
 */
 
void level300() :{}
{
	level299()	
	[LOOKAHEAD(1) postfix300() ]
}

void postfix300():{}
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
{
  ASTFullForm jjtn002 = new ASTFullForm(JJTFULLFORM);
  boolean jjtc002 = true;
  jjtree.openNodeScope(jjtn002);
}
try {
/*@egen*/
(/*@bgen(jjtree) MyID */
                {
                  ASTMyID jjtn001 = new ASTMyID(JJTMYID);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/	
	 	(<CompoundExpression>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001, true);
                                          jjtc001 = false;
                                        }
/*@egen*/	{jjtn001.setValue("Null"); })/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/	
		[LOOKAHEAD(1) {jjtree.popNode();}  term300()	]				
	 		
	{jjtn002.setHead("CompoundExpression");}

)+/*@bgen(jjtree)*/
} catch (Throwable jjte002) {
  if (jjtc002) {
    jjtree.clearNodeScope(jjtn002);
    jjtc002 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte002 instanceof RuntimeException) {
    throw (RuntimeException)jjte002;
  }
  if (jjte002 instanceof ParseException) {
    throw (ParseException)jjte002;
  }
  throw (Error)jjte002;
} finally {
  if (jjtc002) {
    jjtree.closeNodeScope(jjtn002,  jjtree . nodeArity ( ) + 1);
  }
}
/*@egen*/
	
[LOOKAHEAD(1)	tightercheck299()]

}

void term300():{}
{			

(	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level299()
)								
}

void tightercheck300() : {} {
(
		  postfix300()
		| tightercheck299()
)									
}




//Stub Function for the Set-related operators

void level299():{}
{
	
	level298() 			
	[LOOKAHEAD(1)  postfix299()]
	
}

void postfix299():{}
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
	    {jjtn001.setHeadLocation(-1);} //This means last (python style)
		level299Helper()		
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/										
}

void level299Helper():{
}{
(
	(	
		level299Tag() 			
		level299Setter("Tag")
	)
	|	level299Setter("")
	|	level299UpSetter()
)																	
}

void level299Setter(String tag)        :{/*@bgen(jjtree) #MyID( 0) */
  ASTMyID jjtn000 = new ASTMyID(JJTMYID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MyID( 0) */
        try {
/*@egen*/ 
	level299Set()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000,  0);
                                          jjtc000 = false;
                                        }
/*@egen*/ 			{jjtn000.setValue(tag+"Set");}		
|	level299SetDelayed()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000,  0);
                                  jjtc000 = false;
                                }
/*@egen*/ 	{jjtn000.setValue(tag+"SetDelayed");}		
|	level299Unset()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000,  0);
                                          jjtc000 = false;
                                        }
/*@egen*/ 		{jjtn000.setValue(tag+"Unset");}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/		
}

void level299UpSetter()        :{/*@bgen(jjtree) #MyID( 0) */
  ASTMyID jjtn000 = new ASTMyID(JJTMYID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) #MyID( 0) */
        try {
/*@egen*/ 

	level299UpSet()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000,  0);
                                          jjtc000 = false;
                                        }
/*@egen*/ 		{jjtn000.setValue("UpSet");}
|	level299UpSetDelayed()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000,  0);
                                  jjtc000 = false;
                                }
/*@egen*/ 	{jjtn000.setValue("UpSetDelayed");}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  0);
          }
        }
/*@egen*/
											
}
			
void level299Tag() :{}{
	<Tag>		
	tagterm299()				
}

void level299Set() :{}{
	<Set>		
	term299()							
}

void level299SetDelayed() : {}{
	<SetDelayed>		
	term299()					
}

void level299UpSet(): {}{
	<UpSet>  
	term299()						
}

void level299UpSetDelayed() : {}{
	<UpSetDelayed>			
	term299()							
}


void term299(): {}{
	(
		looserPrefix300()
	|	level298()
	)
	[LOOKAHEAD(1) tightercheck299()]	//this makes it right assoc.						
}

void tagterm299(): {}{
		level298()
}

void level299Unset() :{}{
	<Unset>		
}

void tightercheck299() : {} 
{
		  postfix299()
		| tightercheck298()		
}



//Stub function for postApply a//b ==> b[a]   a//b//c ==> c[b[a]]

void level298() : {}
{
	level297()
	
	[ LOOKAHEAD(1) postfix298()	]
}

void postfix298(): {}
{
		<SlashSlash>				
				
		term298()
		//If found token, look for tighter post tokens.		
		[LOOKAHEAD(1) tightercheck298()]
}


void term298()            :{/*@bgen(jjtree) #FullForm( 2) */
ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
jjtn000.setHeadLocation(1);
}{/*@bgen(jjtree) #FullForm( 2) */
         try {
/*@egen*/
	 looserPrefix300()		
	| level297()/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000,  2);
           }
         }
/*@egen*/ 			
}

void tightercheck298() : {} {

		   postfix298()
		|  tightercheck297()

}



//Stub Function for flat operator

void level297() : {}
{
	level296()  	
	[ 	LOOKAHEAD(1)
		postfix297() 
	]												}

void postfix297()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("Colon");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<Colon>							
		term297()
	)+
	(LOOKAHEAD(1)
	 tightercheck296())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term297():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level296()
}

void tightercheck297() : {} {

		  postfix297()
		| tightercheck296()
}



//Stub function for postfix unary operations

void level296():
{}
{
	  level295()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix296()
	  ]			
														
}

void postfix296():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("Function");}
		<Function> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck296()
	)*		
}

void tightercheck296() : {} {
(
		  postfix296()
		| tightercheck295()
)												}



//Stub Function for right-associative operators

void level295():{}
{
	level294()  	
	[ 	LOOKAHEAD(1)
		postfix295() 
		[	LOOKAHEAD(1)
			tightercheck295()
		]
	]
}

void postfix295() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("DivideBy");}
		<DivideBy>
		term295()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix295()
	]
}

void term295():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level294()
}

void tightercheck295(): {} {
		LOOKAHEAD(1)
		  postfix295()
		| tightercheck294()
}


//Stub Function for right-associative operators

void level294():{}
{
	level293()  	
	[ 	LOOKAHEAD(1)
		postfix294() 
		[	LOOKAHEAD(1)
			tightercheck294()
		]
	]
}

void postfix294() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("TimesBy");}
		<TimesBy>
		term294()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix294()
	]
}

void term294():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level293()
}

void tightercheck294(): {} {
		LOOKAHEAD(1)
		  postfix294()
		| tightercheck293()
}


//Stub Function for right-associative operators

void level293():{}
{
	level292()  	
	[ 	LOOKAHEAD(1)
		postfix293() 
		[	LOOKAHEAD(1)
			tightercheck293()
		]
	]
}

void postfix293() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("SubtractFrom");}
		<SubtractFrom>
		term293()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix293()
	]
}

void term293():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level292()
}

void tightercheck293(): {} {
		LOOKAHEAD(1)
		  postfix293()
		| tightercheck292()
}


//Stub Function for right-associative operators

void level292():{}
{
	level291()  	
	[ 	LOOKAHEAD(1)
		postfix292() 
		[	LOOKAHEAD(1)
			tightercheck292()
		]
	]
}

void postfix292() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("AddTo");}
		<AddTo>
		term292()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix292()
	]
}

void term292():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level291()
}

void tightercheck292(): {} {
		LOOKAHEAD(1)
		  postfix292()
		| tightercheck291()
}


//Stub Function for LEFT associative operator

void level291():
{}
{
	level290()  	
	[ 	LOOKAHEAD(1)
		postfix291() 
	]
}



void postfix291():{}
{
	<ReplaceRepeated>
	term291()				
	[	LOOKAHEAD(1) 
		tightercheck291()
	]		
}


void term291()            :
{/*@bgen(jjtree) #FullForm( 2) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("ReplaceRepeated");
}
{/*@bgen(jjtree) #FullForm( 2) */
                  try {
/*@egen*/			
		  looserPrefix300()
	|	  level290()/*@bgen(jjtree)*/
                  } catch (Throwable jjte000) {
                    if (jjtc000) {
                      jjtree.clearNodeScope(jjtn000);
                      jjtc000 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte000 instanceof RuntimeException) {
                      throw (RuntimeException)jjte000;
                    }
                    if (jjte000 instanceof ParseException) {
                      throw (ParseException)jjte000;
                    }
                    throw (Error)jjte000;
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000,  2);
                    }
                  }
/*@egen*/
}

void tightercheck291() : {} {

		  postfix291()
		| tightercheck290()
}


//Stub Function for LEFT associative operator

void level290():
{}
{
	level289()  	
	[ 	LOOKAHEAD(1)
		postfix290() 
	]
}



void postfix290():{}
{
	<ReplaceAll>
	term290()				
	[	LOOKAHEAD(1) 
		tightercheck290()
	]		
}


void term290()            :
{/*@bgen(jjtree) #FullForm( 2) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("ReplaceAll");
}
{/*@bgen(jjtree) #FullForm( 2) */
                  try {
/*@egen*/			
		  looserPrefix300()
	|	  level289()/*@bgen(jjtree)*/
                  } catch (Throwable jjte000) {
                    if (jjtc000) {
                      jjtree.clearNodeScope(jjtn000);
                      jjtc000 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte000 instanceof RuntimeException) {
                      throw (RuntimeException)jjte000;
                    }
                    if (jjte000 instanceof ParseException) {
                      throw (ParseException)jjte000;
                    }
                    throw (Error)jjte000;
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000,  2);
                    }
                  }
/*@egen*/
}

void tightercheck290() : {} {

		  postfix290()
		| tightercheck289()
}


//Stub Function for right-associative operators

void level289():{}
{
	level288()  	
	[ 	LOOKAHEAD(1)
		postfix289() 
		[	LOOKAHEAD(1)
			tightercheck289()
		]
	]
}

void postfix289() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("RuleDelayed");}
		<RuleDelayed>
		term289()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix289()
	]
}

void term289():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level288()
}

void tightercheck289(): {} {
		LOOKAHEAD(1)
		  postfix289()
		| tightercheck288()
}


//Stub Function for right-associative operators

void level288():{}
{
	level287()  	
	[ 	LOOKAHEAD(1)
		postfix288() 
		[	LOOKAHEAD(1)
			tightercheck288()
		]
	]
}

void postfix288() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("Rule");}
		<Rule>
		term288()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix288()
	]
}

void term288():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level287()
}

void tightercheck288(): {} {
		LOOKAHEAD(1)
		  postfix288()
		| tightercheck287()
}


//Stub Function for LEFT associative operator

void level287():
{}
{
	level286()  	
	[ 	LOOKAHEAD(1)
		postfix287() 
	]
}



void postfix287():{}
{
	<Condition>
	term287()				
	[	LOOKAHEAD(1) 
		tightercheck287()
	]		
}


void term287()            :
{/*@bgen(jjtree) #FullForm( 2) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("Condition");
}
{/*@bgen(jjtree) #FullForm( 2) */
                  try {
/*@egen*/			
		  looserPrefix300()
	|	  level286()/*@bgen(jjtree)*/
                  } catch (Throwable jjte000) {
                    if (jjtc000) {
                      jjtree.clearNodeScope(jjtn000);
                      jjtc000 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte000 instanceof RuntimeException) {
                      throw (RuntimeException)jjte000;
                    }
                    if (jjte000 instanceof ParseException) {
                      throw (ParseException)jjte000;
                    }
                    throw (Error)jjte000;
                  } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000,  2);
                    }
                  }
/*@egen*/
}

void tightercheck287() : {} {

		  postfix287()
		| tightercheck286()
}


//Stub Function for flat operator

void level286() : {}
{
	level285()  	
	[ 	LOOKAHEAD(1)
		postfix286() 
	]												}

void postfix286()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("StringExpression");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<StringExpression>							
		term286()
	)+
	(LOOKAHEAD(1)
	 tightercheck285())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term286():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level285()
}

void tightercheck286() : {} {

		  postfix286()
		| tightercheck285()
}



//Stub Function for flat operator

void level285() : {}
{
	level284()  	
	[ 	LOOKAHEAD(1)
		postfix285() 
	]												}

void postfix285()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("Alternatives");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<Alternatives>							
		term285()
	)+
	(LOOKAHEAD(1)
	 tightercheck284())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term285():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level284()
}

void tightercheck285() : {} {

		  postfix285()
		| tightercheck284()
}



//Stub function for postfix unary operations

void level284():
{}
{
	  level283()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix284()
	  ]			
														
}

void postfix284():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("RepeatedNull");}
		<RepeatedNull> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck284()
	)*		
}

void tightercheck284() : {} {
(
		  postfix284()
		| tightercheck283()
)												}



//Stub function for postfix unary operations

void level283():
{}
{
	  level282()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix283()
	  ]			
														
}

void postfix283():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("Repeated");}
		<Repeated> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck283()
	)*		
}

void tightercheck283() : {} {
(
		  postfix283()
		| tightercheck282()
)												}



//Stub Function for flat operator

void level282() : {}
{
	level281()  	
	[ 	LOOKAHEAD(1)
		postfix282() 
	]												}

void postfix282()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("Or");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<Or>							
		term282()
	)+
	(LOOKAHEAD(1)
	 tightercheck281())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term282():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level281()
}

void tightercheck282() : {} {

		  postfix282()
		| tightercheck281()
}



//Stub Function for flat operator

void level281() : {}
{
	level280()  	
	[ 	LOOKAHEAD(1)
		postfix281() 
	]												}

void postfix281()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("And");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<And>							
		term281()
	)+
	(LOOKAHEAD(1)
	 tightercheck280())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term281():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level280()
}

void tightercheck281() : {} {

		  postfix281()
		| tightercheck280()
}



//Stub Function for general PRE Unary operation

void level280():{}
{
	  prefix280()
	| level279() 
}

void prefix280()         :
{/*@bgen(jjtree) FullForm */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("Not");
}
{/*@bgen(jjtree) FullForm */
        try {
/*@egen*/
	<Not>					
	term280()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void term280():
{}
{
	//here we are "protected" by our token, 
	//so we look for a looser token
	//as well as our token again
	//and the tighter terms in general

		  looserPrefix300()
	|	  level279()
}

//standard "empty" post helper.
void tightercheck280():{}
{
	tightercheck279()
}

void looserPrefix280() : {}
{
	  prefix280() 			
	| looserPrefix300()		
}




//Stub Function for flat operator

void level279() : {}
{
	level278()  	
	[ 	LOOKAHEAD(1)
		postfix279() 
	]												}

void postfix279()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("UnsameQ");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<UnsameQ>							
		term279()
	)+
	(LOOKAHEAD(1)
	 tightercheck278())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term279():{}{			

		LOOKAHEAD(1)
		looserPrefix280()
	|	level278()
}

void tightercheck279() : {} {

		  postfix279()
		| tightercheck278()
}



//Stub Function for flat operator

void level278() : {}
{
	level277()  	
	[ 	LOOKAHEAD(1)
		postfix278() 
	]												}

void postfix278()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("SameQ");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<SameQ>							
		term278()
	)+
	(LOOKAHEAD(1)
	 tightercheck277())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term278():{}{			

		LOOKAHEAD(1)
		looserPrefix280()
	|	level277()
}

void tightercheck278() : {} {

		  postfix278()
		| tightercheck277()
}



// This holds the production of inequalities.

void level277():{}
{
	level276()		
	[ 	LOOKAHEAD(1)
		postfix277() 
	]																						
}

void postfix277():{}
{/*@bgen(jjtree) #Inequality( jjtree . nodeArity ( ) + 1) */
        {
          ASTInequality jjtn001 = new ASTInequality(JJTINEQUALITY);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	( LOOKAHEAD(1)
		
			token277() 	
	)+/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/										
}


void token277():{}
{
	  less277()			
	| lessEqual277()	
	| greater277()		
	| greaterEqual277()	
	| equal277()		
	| unequal277()												
}

void less277():{}
{/*@bgen(jjtree) MyID */
        {
          ASTMyID jjtn001 = new ASTMyID(JJTMYID);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<Less>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn001, true);
                 jjtc001 = false;
               }
/*@egen*/{jjtn001.setValue("Less");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	term277()
}	

void lessEqual277():{}
{/*@bgen(jjtree) MyID */
        {
          ASTMyID jjtn001 = new ASTMyID(JJTMYID);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<LessEqual>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn001, true);
                       jjtc001 = false;
                     }
/*@egen*/ {jjtn001.setValue("LessEqual");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	term277()	
}	

void greater277():{}
{/*@bgen(jjtree) MyID */
        {
          ASTMyID jjtn001 = new ASTMyID(JJTMYID);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<Greater>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtc001 = false;
                  }
/*@egen*/{jjtn001.setValue("Greater");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	term277()
}	

void greaterEqual277():{}
{/*@bgen(jjtree) MyID */
        {
          ASTMyID jjtn001 = new ASTMyID(JJTMYID);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<GreaterEqual>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn001, true);
                         jjtc001 = false;
                       }
/*@egen*/{jjtn001.setValue("GreaterEqual");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	term277()
}	

void equal277():{}
{/*@bgen(jjtree) MyID */
        {
          ASTMyID jjtn001 = new ASTMyID(JJTMYID);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<Equal>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/{jjtn001.setValue("Equal");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	term277()
}	

void unequal277():{}
{/*@bgen(jjtree) MyID */
        {
          ASTMyID jjtn001 = new ASTMyID(JJTMYID);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<Unequal>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtc001 = false;
                  }
/*@egen*/{jjtn001.setValue("Unequal");})/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	term277()
}	

void term277():{}
{			
	LOOKAHEAD(1)
	//since we found our token, we look for looser prefix operators
	//decorating our next term
		  looserPrefix280()
	|	  level276()		
}

void tightercheck277() : {} 
{
		  postfix277()
		| tightercheck276()
}




//Stub Function for the flat operator Plus. this is 
//special because of the need to accept Plus and minus and
// do interesting stuff with them


void level276():{}
{
	level275()  	
	[ 	LOOKAHEAD(1)
		postfix276() 
	]								
}
void postfix276() :{}
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
{
  ASTFullForm jjtn003 = new ASTFullForm(JJTFULLFORM);
  boolean jjtc003 = true;
  jjtree.openNodeScope(jjtn003);
}
try {
/*@egen*/
(
	LOOKAHEAD(1)(/*@bgen(jjtree) #PlusTerm(> 1) */
        {
          ASTPlusTerm jjtn002 = new ASTPlusTerm(JJTPLUSTERM);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	(
		(
		  (LOOKAHEAD(1) <PLUS>)+ 	
		| (LOOKAHEAD(1) <MINUS>/*@bgen(jjtree) MyInteger */
                                        {
                                          ASTMyInteger jjtn001 = new ASTMyInteger(JJTMYINTEGER);
                                          boolean jjtc001 = true;
                                          jjtree.openNodeScope(jjtn001);
                                        }
                                        try {
/*@egen*//*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001, true);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.setValue(-1);}/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc001) {
                                            jjtree.closeNodeScope(jjtn001, true);
                                          }
                                        }
/*@egen*/   )+	
		) 
		
		term276()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/				
//	{if((jjtree.peekNode() instanceof ASTPlusTerm) &&jjtree.peekNode().jjtGetNumChildren()==1){
//		Node n=jjtree.popNode();
//		jjtree.pushNode(n.jjtGetChild(0));
//	}}
			{jjtn003.setHead("Plus");}
	)
	
)+/*@bgen(jjtree)*/
} catch (Throwable jjte003) {
  if (jjtc003) {
    jjtree.clearNodeScope(jjtn003);
    jjtc003 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte003 instanceof RuntimeException) {
    throw (RuntimeException)jjte003;
  }
  if (jjte003 instanceof ParseException) {
    throw (ParseException)jjte003;
  }
  throw (Error)jjte003;
} finally {
  if (jjtc003) {
    jjtree.closeNodeScope(jjtn003,  jjtree . nodeArity ( ) + 1);
  }
}
/*@egen*/

[LOOKAHEAD(1) tightercheck276()]

}

void term276() :{}
{
(	
	//since we found our token, we look for looser prefix operators
	//decorating our next term
	(
	  looserPrefix280() 
	| level275()
	)

) 		
}

void tightercheck276() : {} {
(
	  postfix276()
	| tightercheck275()
)									
}



//Stub Function for flat operator

void level275() : {}
{
	level274()  	
	[ 	LOOKAHEAD(1)
		postfix275() 
	]												}

void postfix275()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("CirclePlus");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<CirclePlus>							
		term275()
	)+
	(LOOKAHEAD(1)
	 tightercheck274())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term275():{}{			

		LOOKAHEAD(1)
		looserPrefix280()
	|	level274()
}

void tightercheck275() : {} {

		  postfix275()
		| tightercheck274()
}



//Stub Function for the flat operator Times. this is 
//special because of the need to accept implicit multiply.
//the level that takes care of unary plus and minus MUST be directly
//below this level (i.e the operators must be above) so that it can skip it...


void level274():{}
{
	level273()  	
	[ 	LOOKAHEAD(1)
		postfix274() 
	]								
}

void postfix274():{}
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        {
          ASTFullForm jjtn003 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	//Explicit
	(LOOKAHEAD(1)
		{jjtn003.setHead("Times");}
		(/*@bgen(jjtree) #FullForm(> 1) */
                        {
                          ASTFullForm jjtn002 = new ASTFullForm(JJTFULLFORM);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/	
			(
				{jjtn002.setHead("Power");
				 jjtn002.reverseChildren();}
				 
				(
				  (  <TIMES>)						
		   		|/*@bgen(jjtree) #MyInteger(true) */
                                  {
                                    ASTMyInteger jjtn001 = new ASTMyInteger(JJTMYINTEGER);
                                    boolean jjtc001 = true;
                                    jjtree.openNodeScope(jjtn001);
                                  }
                                  try {
/*@egen*/ (<DIVIDE>/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn001, true);
                                              jjtc001 = false;
                                            }
/*@egen*/ {jjtn001.setValue(-1);})/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc001) {
                                      jjtree.closeNodeScope(jjtn001, true);
                                    }
                                  }
/*@egen*/						
				)
				explicitTerm274()				

			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, jjtree.nodeArity() > 1);
                          }
                        }
/*@egen*/
			|
			//Implicit
			implicitTerm274()
		)
	)+/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/
		
	[LOOKAHEAD(1) 	tightercheck273()]	
}


void explicitTerm274():{}
{			
	(	LOOKAHEAD(1)
		  looserPrefix280()
		| level273()
	)			
}

void implicitTerm274():{}
{			
		//No token, nothing to "protect" looser tokens.
		//allow only if no plus, i.e skip over next level

	level272() 
}

void tightercheck274() : {} 
{
	(	LOOKAHEAD(1)
		  postfix274()
		| tightercheck273()
	)			
}





//Stub Function for PRE PLUS and MINUS Unary operation

//Nota Bene: This level must occur directly under the one for multiply since 
//we allow for implicit multiply and the only prefix operators that cannot
//partake in that are + and -.


void level273():{}{
(	  prefix273()
	| level272() 
)		
}


void prefix273()              :{/*@bgen(jjtree) #PlusTerm(> 1) */
  ASTPlusTerm jjtn000 = new ASTPlusTerm(JJTPLUSTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) #PlusTerm(> 1) */
try {
/*@egen*/
(
  	(<PLUS>)+	
| 	(<MINUS>/*@bgen(jjtree) MyInteger */
                        {
                          ASTMyInteger jjtn001 = new ASTMyInteger(JJTMYINTEGER);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*//*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/  	{jjtn001.setValue(-1);}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                          }
                        }
/*@egen*/   )+ 
)

	term273()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
  }
}
/*@egen*/

}
void term273() :{} {

	( looserPrefix280() 
	| level272()
	)
}

//standard "empty" post helper.
void tightercheck273():{}
{
	tightercheck272()
}


void looserPrefix273() : {}
{
	  prefix273() 				
	| looserPrefix280()	
}




//Stub Function for right-associative operators

void level272():{}
{
	level271()  	
	[ 	LOOKAHEAD(1)
		postfix272() 
		[	LOOKAHEAD(1)
			tightercheck272()
		]
	]
}

void postfix272() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("Power");}
		<Power>
		term272()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix272()
	]
}

void term272():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level271()
}

void tightercheck272(): {} {
		LOOKAHEAD(1)
		  postfix272()
		| tightercheck271()
}


//Stub Function for flat operator

void level271() : {}
{
	level270()  	
	[ 	LOOKAHEAD(1)
		postfix271() 
	]												}

void postfix271()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("StringJoin");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<StringJoin>							
		term271()
	)+
	(LOOKAHEAD(1)
	 tightercheck270())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term271():{}{			

		LOOKAHEAD(1)
		looserPrefix273()
	|	level270()
}

void tightercheck271() : {} {

		  postfix271()
		| tightercheck270()
}



//Stub Function for the pattern creation (Using ':')

void level270():{}
{
	
		level269()
		
		[LOOKAHEAD(1) postfix270()]
									
}
void postfix270():{}
{/*@bgen(jjtree) #Optional( jjtree . nodeArity ( ) + 1) */
        {
          ASTOptional jjtn001 = new ASTOptional(JJTOPTIONAL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(LOOKAHEAD(1) optionalHelper270())+/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/
}


void optionalHelper270():{}
{
	
	//a colon means different things depending on the Head of the previous 
	//term. We just collect the various terms in a big "Optional" Node and let
	//it chug away at it.
	(
	<Optional>
	term270()
	)


}


void term270(): {}
{
	(LOOKAHEAD(1)
	 	looserPrefix273()
	|	level269()
	)	
}


void tightercheck270() : {} 
{
(
		 tightercheck269()
		 
)										
}




//Stub function for postfix unary operations

void level269():
{}
{
	  level268()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix269()
	  ]			
														
}

void postfix269():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("Factorial");}
		<Not> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck269()
	)*		
}

void tightercheck269() : {} {
(
		  postfix269()
		| tightercheck268()
)												}



//Stub function for postfix unary operations

void level268():
{}
{
	  level267()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix268()
	  ]			
														
}

void postfix268():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("Factorial2");}
		<Factorial2> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck268()
	)*		
}

void tightercheck268() : {} {
(
		  postfix268()
		| tightercheck267()
)												}



//Stub Function for Deep Apply f @@@ g ==> Apply[f, g, List[1]]

void level267():{} {

	level266()  	
	[ 	LOOKAHEAD(1)
		postfix267() 
		[	LOOKAHEAD(1)
			tightercheck267()
		]
	]
}



void postfix267() :{}
{/*@bgen(jjtree) #FullForm( 3) */
        {
          ASTFullForm jjtn003 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
	(	
		{jjtn003.setHead("Apply");}
		<DeepApply>
		term267()/*@bgen(jjtree) FullForm */
                {
                  ASTFullForm jjtn002 = new ASTFullForm(JJTFULLFORM);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/
		({jjtn002.setHead("List");}/*@bgen(jjtree) #MyInteger(true) */
                                            {
                                              ASTMyInteger jjtn001 = new ASTMyInteger(JJTMYINTEGER);
                                              boolean jjtc001 = true;
                                              jjtree.openNodeScope(jjtn001);
                                            }
                                            try {
/*@egen*/ (/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001, true);
                                               jjtc001 = false;
                                             }
/*@egen*/{jjtn001.setValue("1");})/*@bgen(jjtree)*/
                                            } finally {
                                              if (jjtc001) {
                                                jjtree.closeNodeScope(jjtn001, true);
                                              }
                                            }
/*@egen*/    )/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte003) {
          if (jjtc003) {
            jjtree.clearNodeScope(jjtn003);
            jjtc003 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte003 instanceof RuntimeException) {
            throw (RuntimeException)jjte003;
          }
          if (jjte003 instanceof ParseException) {
            throw (ParseException)jjte003;
          }
          throw (Error)jjte003;
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003,  3);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix267()
	]
}

void term267():{}
{			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level266()
}


void tightercheck267(): {} {
		LOOKAHEAD(1)
		  postfix267()
		| tightercheck266()
}


//Stub Function for right-associative operators

void level266():{}
{
	level265()  	
	[ 	LOOKAHEAD(1)
		postfix266() 
		[	LOOKAHEAD(1)
			tightercheck266()
		]
	]
}

void postfix266() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("Apply");}
		<Apply>
		term266()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix266()
	]
}

void term266():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level265()
}

void tightercheck266(): {} {
		LOOKAHEAD(1)
		  postfix266()
		| tightercheck265()
}


//Stub Function for right-associative operators

void level265():{}
{
	level264()  	
	[ 	LOOKAHEAD(1)
		postfix265() 
		[	LOOKAHEAD(1)
			tightercheck265()
		]
	]
}

void postfix265() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("ApplyAll");}
		<ApplyAll>
		term265()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix265()
	]
}

void term265():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level264()
}

void tightercheck265(): {} {
		LOOKAHEAD(1)
		  postfix265()
		| tightercheck264()
}


//Stub Function for right-associative operators

void level264():{}
{
	level263()  	
	[ 	LOOKAHEAD(1)
		postfix264() 
		[	LOOKAHEAD(1)
			tightercheck264()
		]
	]
}

void postfix264() :{}{/*@bgen(jjtree) #FullForm( 2) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(	
		{jjtn001.setHead("Map");}
		<Map>
		term264()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/			
	
	[	LOOKAHEAD(1)
		postfix264()
	]
}

void term264():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level263()
}

void tightercheck264(): {} {
		LOOKAHEAD(1)
		  postfix264()
		| tightercheck263()
}


//Stub Function for "mid-fix" operator ~ (as in a~h~b -> h[a,b])

void level263():{}
{
	level262()  				
		
	[LOOKAHEAD(1) 
		postfix263()
	]		
}

void postfix263(): {}
{
(	LOOKAHEAD(1)/*@bgen(jjtree) #FullForm( 3) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		{jjtn001.setHeadLocation(1);}
		<Tilde>
		term263()			
		<Tilde>
		term263()

	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  3);
          }
        }
/*@egen*/			
)+														
(		LOOKAHEAD(1) 
		 tightercheck263())*		
}

void term263():{}{			

(	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level262()
)												
}


void tightercheck263() : {} {
(
		LOOKAHEAD(1)
		  postfix263()
		| tightercheck262()
)												
}





//Stub function for preApply a@b ==> a[b]  a@b@c ==> a[b[c]]
void level262() : {}
{
	level261()
	
	[ LOOKAHEAD(1) postfix262()	]
}





void postfix262(): {}
{
		(
		<At>				
		term262()
		)						
		
		(LOOKAHEAD(1) tightercheck262())*
														
}


void term262()            :
{/*@bgen(jjtree) #FullForm( 2) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHeadLocation(0);
}
{/*@bgen(jjtree) #FullForm( 2) */
        try {
/*@egen*/
	( 
	 looserPrefix273()		
	| level261() )	

	[LOOKAHEAD(1) postfix262()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  2);
          }
        }
/*@egen*/

}

void tightercheck262() : {} {
(
		  postfix262()
		| tightercheck261()
)												
}



//Stub Function for general PRE Unary operation

void level261():{}
{
	  prefix261()
	| level260() 
}

void prefix261()         :
{/*@bgen(jjtree) FullForm */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("PreDecrement");
}
{/*@bgen(jjtree) FullForm */
        try {
/*@egen*/
	<PreDecrement>					
	term261()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void term261():
{}
{
	//here we are "protected" by our token, 
	//so we look for a looser token
	//as well as our token again
	//and the tighter terms in general

		  looserPrefix273()
	|	  level260()
}

//standard "empty" post helper.
void tightercheck261():{}
{
	tightercheck260()
}

void looserPrefix261() : {}
{
	  prefix261() 			
	| looserPrefix273()		
}




//Stub Function for general PRE Unary operation

void level260():{}
{
	  prefix260()
	| level259() 
}

void prefix260()         :
{/*@bgen(jjtree) FullForm */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("PreIncrement");
}
{/*@bgen(jjtree) FullForm */
        try {
/*@egen*/
	<PreIncrement>					
	term260()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void term260():
{}
{
	//here we are "protected" by our token, 
	//so we look for a looser token
	//as well as our token again
	//and the tighter terms in general

		  looserPrefix261()
	|	  level259()
}

//standard "empty" post helper.
void tightercheck260():{}
{
	tightercheck259()
}

void looserPrefix260() : {}
{
	  prefix260() 			
	| looserPrefix261()		
}




//Stub function for postfix unary operations

void level259():
{}
{
	  level258()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix259()
	  ]			
														
}

void postfix259():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("Decrement");}
		<PreDecrement> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck259()
	)*		
}

void tightercheck259() : {} {
(
		  postfix259()
		| tightercheck258()
)												}



//Stub function for postfix unary operations

void level258():
{}
{
	  level257()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix258()
	  ]			
														
}

void postfix258():
{} 
{/*@bgen(jjtree) #FullForm( 1) */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	({jjtn001.setHead("Increment");}
		<PreIncrement> )/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/ 									

	(
		LOOKAHEAD(1) 
			tightercheck258()
	)*		
}

void tightercheck258() : {} {
(
		  postfix258()
		| tightercheck257()
)												}



//Stub Function for flat operator

void level257() : {}
{
	level256()  	
	[ 	LOOKAHEAD(1)
		postfix257() 
	]												}

void postfix257()                                :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("MessageName");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	(LOOKAHEAD(1)
		<MessageName>							
		term257()
	)+
	(LOOKAHEAD(1)
	 tightercheck256())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/	
}

void term257():{}{			

		LOOKAHEAD(1)
		looserPrefix260()
	|	level256()
}

void tightercheck257() : {} {

		  postfix257()
		| tightercheck256()
}





//End of automatic level creation


void tightercheck256(): {} {
	tightercheckFullForm()
}

void level256() :{}
{
	fullFormExpression()
}

//A "Pass-Through" PrefixHelper to connect lower layers
void prefixBase(): {} 
{
	// no token, so just look for looser prefix
	 looserPrefix260() 	
}

void fullFormExpression() :{}
{
	  partExpression()					
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [	LOOKAHEAD(1) postfixFullForm()]			
}

void postfixFullForm(): {}
{
		fullFormTail()		
		(	LOOKAHEAD(1) 
			tightercheckFullForm()
		)*	
}

void fullFormTail()                                 :
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHeadLocation(0);
}
{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	<LBRACKET> 	
	[
		syntaxExpression() 					
		( 
		  	<COMMA>
	  		syntaxExpression()						
		)* 
	]
	<RBRACKET>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/ 							
}

void tightercheckFullForm() : {} {
	postfixFullForm()
|	tightercheckPart()
}

void partExpression() : {}
{
	  patternTestExpression()				
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [LOOKAHEAD(1) postfixPart()]			
}

void postfixPart(): {}
{
		partTail()
		(LOOKAHEAD(1) tightercheckPart())*		
}

void partTail()                                :{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("Part");
}{/*@bgen(jjtree) #FullForm( jjtree . nodeArity ( ) + 1) */
        try {
/*@egen*/
	<TwoLBRACKETS> 				
	
	syntaxExpression()					 					
	( 
		<COMMA>
	   	syntaxExpression()						
	)*			
	<RBRACKET><RBRACKET>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) + 1);
          }
        }
/*@egen*/ 							
}

void tightercheckPart() : {} {
		  postfixPart()
		| tightercheckPatternTest()								
}

//Function for a PatternTest expression a?b => PatternTest[a,b] 

void patternTestExpression() :{}{

	(LOOKAHEAD(2,(symbolExpression()blankExpression())|blankExpression(),
                 {getToken(1).kind!=SYMBOL||getToken(2).specialToken==null})
	 patternExpression()  	
	|atomicExpression() )

	[ 	LOOKAHEAD(1)
		postfixPatternTest() 
	]
}

void postfixPatternTest()              :
{/*@bgen(jjtree) #FullForm( 2) */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("PatternTest");
}{/*@bgen(jjtree) #FullForm( 2) */
        try {
/*@egen*/
	<QUESTIONMARK> 								
	termPatternTest()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  2);
          }
        }
/*@egen*/	
}

void termPatternTest():{}
{				
//		prefixBase()
		LOOKAHEAD(2,(symbolExpression()blankExpression())|blankExpression(),
                 {getToken(1).kind!=SYMBOL||getToken(2).specialToken==null})
		patternExpression()
	| 	atomicExpression()
}

void tightercheckPatternTest() : {} {
		  postfixPatternTest()	
}

void atomicExpression() :{}
{
	outExpression()					
|	slotExpression()
	/*
	 * Since pattern expression begins with a raw expression, 
	 * we need a lookahead of 2.
	 *
	 * a Null special token indicates that it is a whitespace, since that is the
	 * only kind of specialToken that we currently have....
	 */			
|	nonNegativeInteger()			
		/*
		 * FIXME not yet implemented
		 */
//	|	a = nonNegativeReal()
	    /*
	     * Make sure you read the comment about negative integers, above.
	     * Quite likely the same will apply here.
	     */

|   literalString() 
|   parenthesisedExpression() 
|	bracedExpression()			
|   symbolExpression()
}



void outExpression() :
{
	ASTMyInteger a = new ASTMyInteger(JJTMYINTEGER);
	a.setValue(-1);
	Integer number=-1;		
}{/*@bgen(jjtree) FullForm */
        {
          ASTFullForm jjtn002 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	
	/*
	 * Here we catch Out expressions.
	 *
	 * % should produce Out[]
	 * %%% or generally, n consecutive percent signs), should produce Out[-n]
	 * %m should produce Out[m] (only for positive integers)
	 */
	
	( {jjtn002.setHead("Out");}<PERCENT>		
	/*
	 * At this point there's a choice; either multiple percent signs, or a number
	 */
	[LOOKAHEAD(1) 
		(/*@bgen(jjtree) MyInteger */
                        {
                          ASTMyInteger jjtn001 = new ASTMyInteger(JJTMYINTEGER);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 		
			( LOOKAHEAD(1)<PERCENT> 			{ number--; jjtn001.setValue(number);} 
			)+/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                          }
                        }
/*@egen*/  								
		|		
			nonNegativeInteger()				
		) 
	]	
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/		
}

void slotExpression() :
{
	ASTMyInteger a=new ASTMyInteger(JJTMYINTEGER);
	a.setValue(1); 
	Node n=(Node)a;
}{
	/*
	 * Here we match things like #, ##, #n and ##n; these occur in pure functions.
	 */
	(/*@bgen(jjtree) FullForm */
                {
                  ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(<HASH> 								{jjtn001.setHead("Slot");}
		[LOOKAHEAD(1)  (nonNegativeInteger() 	{n=jjtree.popNode(); })]
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/  	 		

	|/*@bgen(jjtree) FullForm */
                {
                  ASTFullForm jjtn002 = new ASTFullForm(JJTFULLFORM);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/	(<HASHHASH> 							{jjtn002.setHead("SlotSequence");}
		[LOOKAHEAD(1) nonNegativeInteger() 		{n=jjtree.popNode(); }]
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/  	 

	)		 									{jjtree.peekNode().jjtAddChild(n,0);}
}

/*
 *
 * patternExpression is complicated!
 * 
 * The necessary part is the blankExpression in the middle. This matches one of _, __ and ___
 * Before the blank, we can optionally have a symbol (not an arbitrary expression!).
 *		(this symbol names the pattern)
 * After the blank there are two alternatives:
 *		i) either a . (which means the pattern is optional)
 *		ii) or a symbol, prescribing the head of whatever this blank can match
 *				(this can only be a symbol;
 *					try "_f[x] // FullForm" or "_(f[x]) // FullForm" if you doubt this!)
 *
 * The java code at the bottom builds the appropriate strings.
 */

/* Use 
		LOOKAHEAD(2,(symbolExpression()blankExpression())|blankExpression(),
                 {getToken(1).kind!=SYMBOL||getToken.specialToken==null})

   before calling this production.
*/
void patternExpression():
{
boolean typedBlank=false;
}
{
	
(/*@bgen(jjtree) FullForm */
        {
          ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/	(	{jjtn001.setHead("Pattern");}	
		symbolExpression() 				
		typedBlank=blankExpression()	   		
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
	|
		typedBlank=blankExpression()				
)
[	LOOKAHEAD(1,<PERIOD>,{!typedBlank})/*@bgen(jjtree) #FullForm( 1) */
                {
                  ASTFullForm jjtn002 = new ASTFullForm(JJTFULLFORM);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/
		({jjtn002.setHead("Optional");}	<PERIOD>)/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  1);
                  }
                }
/*@egen*/
]

}


boolean blankExpression():
{
String blankType;
boolean typed=false;
}
{/*@bgen(jjtree) FullForm */
{
  ASTFullForm jjtn001 = new ASTFullForm(JJTFULLFORM);
  boolean jjtc001 = true;
  jjtree.openNodeScope(jjtn001);
}
try {
/*@egen*/
	//here we want to find either a typed blank "_a" or an untyped blank  "_"
	//we return true if the blank is typed, otherwise false.
	
(
	( 
		blankType=blank() 			{jjtn001.setHead(blankType);} 
	)	
	[	LOOKAHEAD(1,symbolExpression(),{getToken(1).specialToken==null})	
			symbolExpression()    	{typed=true;}
	]

)/*@bgen(jjtree)*/
} catch (Throwable jjte001) {
  if (jjtc001) {
    jjtree.clearNodeScope(jjtn001);
    jjtc001 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte001 instanceof RuntimeException) {
    throw (RuntimeException)jjte001;
  }
  if (jjte001 instanceof ParseException) {
    throw (ParseException)jjte001;
  }
  throw (Error)jjte001;
} finally {
  if (jjtc001) {
    jjtree.closeNodeScope(jjtn001, true);
  }
}
/*@egen*/
{return typed;}
}


String blank() :
{
String blankType;
}
{
	/*
	 *	Pretty self explanatory!
	 */

	(
				<BLANK>						{blankType="Blank";}
		|		<BLANKSEQUENCE>				{blankType="BlankSequence";}
		|		<BLANKNULLSEQUENCE>			{blankType="BlankNullSequence";}
	)	{return blankType;}


}


void rawExpression() : {}
{
		/*
		 * Negative integers are dealt with higher up!
		 * In particular, there's a hack in the level for Plus and Minus which produces negative integers properly
		 * 
		 * You should look at flatPlusStub.txt and prePlusStub.txt (at least in REV 268) to work out what's
		 * going on!
		 *
		 * In the current implementation (REV 268), it appears that negative Integers are never actually
		 * caught here they are dealt with by the code in prePlusStub.txt
		 */
		nonNegativeInteger()			
		/*
		 * FIXME not yet implemented
		 */
//	|	a = nonNegativeReal()
	    /*
	     * Make sure you read the comment about negative integers, above.
	     * Quite likely the same will apply here.
	     */

	|   literalString() 
	|   symbolExpression()  			
}

void parenthesisedExpression():{}
{
		<LPAREN> syntaxExpression() <RPAREN>		
}

void bracedExpression()          : 
{/*@bgen(jjtree) FullForm */
        ASTFullForm jjtn000 = new ASTFullForm(JJTFULLFORM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	jjtn000.setHead("List");
}
{/*@bgen(jjtree) FullForm */
                try {
/*@egen*/
		<LBRACE>										
		(
			syntaxExpression()				
			(
				<COMMA>
				syntaxExpression()			
			)*
		)?
		<RBRACE>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/										
}

void nonNegativeInteger()           :
{/*@bgen(jjtree) MyInteger */
        ASTMyInteger jjtn000 = new ASTMyInteger(JJTMYINTEGER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	String number;
}
{/*@bgen(jjtree) MyInteger */
                try {
/*@egen*/
		(t = <NONNEGATIVEINTEGER>			{ number = t.toString(); 
											  while(number.charAt(0)=='0' && number.length()>1)
											  		number = number.substring(1);
											  jjtn000.setValue(number);
											})/*@bgen(jjtree)*/
                                                                                        {
                                                                                          jjtree.closeNodeScope(jjtn000, true);
                                                                                          jjtc000 = false;
                                                                                        }
/*@egen*/
											{}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

/*
 * FIXME
 */ 
void nonNegativeReal() :{}
{
	<FALSE>						
}

void literalString()           :{/*@bgen(jjtree) MyString */
        ASTMyString jjtn000 = new ASTMyString(JJTMYSTRING);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
}{/*@bgen(jjtree) MyString */
        try {
/*@egen*/
	(t = <STRING_LITERAL>		
								{ jjtn000.setValue(t.image); }
	)/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                }
/*@egen*/							{}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void symbolExpression()      :{/*@bgen(jjtree) MyID */
        ASTMyID jjtn000 = new ASTMyID(JJTMYID);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
	String ret;
}{/*@bgen(jjtree) MyID */
        try {
/*@egen*/
	(t = <SYMBOL>	
					{ 	ret = t.toString();
						if (ret.charAt(0)=='`') 
							ret = ret.substring(1); 
						jjtn000.setValue(ret);
					}
	)/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/				{}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
options
{
	STATIC = false; 

	MULTI=true;
  	NODE_DEFAULT_VOID=true;
}




PARSER_BEGIN(SyntaxParser)

package org.omath.parser;

import java.io.StringReader;

import org.omath.parser.ParseException;
import org.omath.parser.Node;
import org.omath.parser.SyntaxParser;
import org.omath.parser.TokenMgrError;

public class SyntaxParser {

	public static Node parseSyntaxString(String input)
			throws org.omath.parser.ParseException {
		SyntaxParser parser = new SyntaxParser(new StringReader(input));
		try {
			return parser.totalExpression().jjtGetChild(0);
		} catch (ParseException e) {
			throw wrappedException(e, input);
		} catch (TokenMgrError e) {
			throw wrappedException(e, input);			
		}
	}
	
	private static ParseException wrappedException(Throwable e, String input) {
		String message = "While attempting to parse ";
		if (input.length() > 500) {
			message += "a very long string:\n";
		} else {
			message += "\n+++\n" + input + "\n+++\n";
		}
		return new ParseException(message + e.getMessage(), e);
	}
}


PARSER_END(SyntaxParser)


TOKEN_MGR_DECLS : {

    int commentNestingDepth ; 
	
}

	/*
	 * we only have one kind of special token, so in the code, I will assume that if
	 * the specialToken field isn't null, it is of kind WHITESPACE. if this changes, you'll
	 * need to add the extra check (mostly related to the patternExpression)
	 */
	 
SPECIAL_TOKEN:
{
  <WHITESPACE: " " | "\t" | "\n" | "\r">
}


// Go into the IN_COMMENT state when an "(*" is encountered
SKIP : {

    "(*" {commentNestingDepth=1;} : IN_COMMENT } 
  
 < IN_COMMENT >  SKIP : {  
// While in the comment "*)" reduces the nesting count
// if nesting count goes down to zero, switch out of this 
 	"*)" 					{commentNestingDepth -= 1;
    						 SwitchTo( commentNestingDepth==0 ? DEFAULT : IN_COMMENT ) ; } 
// if encounter another "*)", increase nesting count.
|	"(*"					{commentNestingDepth++;}

// When any other character is seen in the IN_COMMENT state, skip it.
|    <  ~[] > 
} 

    
//END of code from idevelopment.


// a double quotes changes the lexical state to IN_STRING_LITERAL
MORE : {
    "\"": IN_STRING_LITERAL } 

//in this LEX state, a " pops you back out to default and returns the string as a token 
< IN_STRING_LITERAL > TOKEN : {
   <STRING_LITERAL:"\"">: DEFAULT 
} 

//escaped quotes are OK, but don't escape with an escaped backslash...
< IN_STRING_LITERAL > MORE : {
   < "\\\"" > 
 | < "\\\\" >
  
   } 
 // anything else is also ok.
< IN_STRING_LITERAL > MORE : {
   <  ~[] > } 


         

//TOKEN : 
//{
//	<#Omega: "\\[Omega]">
//|	<#Alpha: "\\[Alpha]">
//|	<#Beta:  "\\[Beta]">
	
//|<#SPECIALCHAR: 
//	<Alpha>
//|	<Beta>
//|	<Omega>
//>
//}   


TOKEN :
{
      <#ImaginaryI: "\\[ImaginaryI]">
|      <#Alpha: "\\[Alpha]">
|      <#Beta: "\\[Beta]">
|      <#Gamma: "\\[Gamma]">
|      <#Delta: "\\[Delta]">
|      <#Epsilon: "\\[Epsilon]">
|      <#CurlyEpsilon: "\\[CurlyEpsilon]">
|      <#Zeta: "\\[Zeta]">
|      <#Eta: "\\[Eta]">
|      <#Theta: "\\[Theta]">
|      <#CurlyTheta: "\\[CurlyTheta]">
|      <#Iota: "\\[Iota]">
|      <#Kappa: "\\[Kappa]">
|      <#CurlyKappa: "\\[CurlyKappa]">
|      <#Lambda: "\\[Lambda]">
|      <#Mu: "\\[Mu]">
|      <#Nu: "\\[Nu]">
|      <#Xi: "\\[Xi]">
|      <#Omicron: "\\[Omicron]">
|      <#Pi: "\\[Pi]">
|      <#CurlyPi: "\\[CurlyPi]">
|      <#Rho: "\\[Rho]">
|      <#CurlyRho: "\\[CurlyRho]">
|      <#Sigma: "\\[Sigma]">
|      <#FinalSigma: "\\[FinalSigma]">
|      <#Tau: "\\[Tau]">
|      <#Upsilon: "\\[Upsilon]">
|      <#Phi: "\\[Phi]">
|      <#CurlyPhi: "\\[CurlyPhi]">
|      <#Chi: "\\[Chi]">
|      <#Psi: "\\[Psi]">
|      <#Omega: "\\[Omega]">
|      <#Digamma: "\\[Digamma]">
|      <#Koppa: "\\[Koppa]">
|      <#Stigma: "\\[Stigma]">
|      <#Sampi: "\\[Sampi]">
|      <#CapitalAlpha: "\\[CapitalAlpha]">
|      <#CapitalBeta: "\\[CapitalBeta]">
|      <#CapitalGamma: "\\[CapitalGamma]">
|      <#CapitalDelta: "\\[CapitalDelta]">
|      <#CapitalEpsilon: "\\[CapitalEpsilon]">
|      <#CapitalZeta: "\\[CapitalZeta]">
|      <#CapitalEta: "\\[CapitalEta]">
|      <#CapitalTheta: "\\[CapitalTheta]">
|      <#CapitalIota: "\\[CapitalIota]">
|      <#CapitalKappa: "\\[CapitalKappa]">
|      <#CapitalLambda: "\\[CapitalLambda]">
|      <#CapitalMu: "\\[CapitalMu]">
|      <#CapitalNu: "\\[CapitalNu]">
|      <#CapitalXi: "\\[CapitalXi]">
|      <#CapitalOmicron: "\\[CapitalOmicron]">
|      <#CapitalPi: "\\[CapitalPi]">
|      <#CapitalRho: "\\[CapitalRho]">
|      <#CapitalSigma: "\\[CapitalSigma]">
|      <#CapitalTau: "\\[CapitalTau]">
|      <#CapitalUpsilon: "\\[CapitalUpsilon]">
|      <#CurlyCapitalUpsilon: "\\[CurlyCapitalUpsilon]">
|      <#CapitalPhi: "\\[CapitalPhi]">
|      <#CapitalChi: "\\[CapitalChi]">
|      <#CapitalPsi: "\\[CapitalPsi]">
|      <#CapitalOmega: "\\[CapitalOmega]">
|      <#CapitalDigamma: "\\[CapitalDigamma]">
|      <#CapitalKoppa: "\\[CapitalKoppa]">
|      <#CapitalStigma: "\\[CapitalStigma]">
|      <#CapitalSampi: "\\[CapitalSampi]">
|<#SPECIALCHAR:
      <ImaginaryI>
|      <Alpha>
|      <Beta>
|      <Gamma>
|      <Delta>
|      <Epsilon>
|      <CurlyEpsilon>
|      <Zeta>
|      <Eta>
|      <Theta>
|      <CurlyTheta>
|      <Iota>
|      <Kappa>
|      <CurlyKappa>
|      <Lambda>
|      <Mu>
|      <Nu>
|      <Xi>
|      <Omicron>
|      <Pi>
|      <CurlyPi>
|      <Rho>
|      <CurlyRho>
|      <Sigma>
|      <FinalSigma>
|      <Tau>
|      <Upsilon>
|      <Phi>
|      <CurlyPhi>
|      <Chi>
|      <Psi>
|      <Omega>
|      <Digamma>
|      <Koppa>
|      <Stigma>
|      <Sampi>
|      <CapitalAlpha>
|      <CapitalBeta>
|      <CapitalGamma>
|      <CapitalDelta>
|      <CapitalEpsilon>
|      <CapitalZeta>
|      <CapitalEta>
|      <CapitalTheta>
|      <CapitalIota>
|      <CapitalKappa>
|      <CapitalLambda>
|      <CapitalMu>
|      <CapitalNu>
|      <CapitalXi>
|      <CapitalOmicron>
|      <CapitalPi>
|      <CapitalRho>
|      <CapitalSigma>
|      <CapitalTau>
|      <CapitalUpsilon>
|      <CurlyCapitalUpsilon>
|      <CapitalPhi>
|      <CapitalChi>
|      <CapitalPsi>
|      <CapitalOmega>
|      <CapitalDigamma>
|      <CapitalKoppa>
|      <CapitalStigma>
|      <CapitalSampi>>
}

TOKEN :
{
  <FALSE: []>
| <PERIOD: ".">
|  <EOL: "\n" | "\r" | "\r\n" > 
| <#DIGIT: ["0"-"9"]>
| <NONNEGATIVEINTEGER: (<DIGIT>)+>
| <#LETTER: ["a"-"z","A"-"Z","$","`"]>
| <#GENLETTER: <LETTER>|<SPECIALCHAR>>
| <#ALPHANUMERIC: <GENLETTER>|<DIGIT>>
| <SYMBOL: <GENLETTER>(<ALPHANUMERIC>)*>
| <LBRACKET: "[">
| <RBRACKET: "]">
| <TwoLBRACKETS: "[[">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <COMMA: ",">
| <BLANK: "_">
| <BLANKSEQUENCE: "__">
| <BLANKNULLSEQUENCE: "___">
| <HASH: "#">
| <HASHHASH: "##">
| <PERCENT: "%">
| <QUESTIONMARK: "?">
| <QUESTIONMARK2: "??">

| <Factorial2: "!!">
| <Apply: "@@">
| <GreaterEqual: ">=">
| <StringExpression: "~~">
| <RepeatedNull: "...">
| <StringJoin: "<>">
| <Or: "||">
| <LessEqual: "<=">
| <Map: "/@">
| <SetDelayed: ":=">
| <RuleDelayed: ":>">
| <DeepApply: "@@@">
| <MessageName: "::">
| <Unequal: "!=">
| <Not: "!">
| <SameQ: "===">
| <UpSet: "^=">
| <Repeated: "..">
| <Function: "&">
| <Colon: "\\[Colon]">
| <PLUS: "+">
| <TIMES: "*">
| <MINUS: "-">
| <DIVIDE: "/">
| <CirclePlus: "\\[CirclePlus]">
| <CompoundExpression: ";">
| <Optional: ":">
| <Set: "=">
| <Less: "<">
| <Greater: ">">
| <TimesBy: "*=">
| <ReplaceRepeated: "//.">
| <Equal: "==">
| <And: "&&">
| <At: "@">
| <Unset: "=.">
| <UpSetDelayed: "^:=">
| <Power: "^">
| <SlashSlash: "//">
| <ReplaceAll: "/.">
| <ApplyAll: "//@">
| <PreDecrement: "--">
| <UnsameQ: "=!=">
| <PreIncrement: "++">
| <DivideBy: "/=">
| <Condition: "/;">
| <Tag: "/:">
| <SubtractFrom: "-=">
| <Rule: "->">
| <Alternatives: "|">
| <AddTo: "+=">
| <Tilde: "~">

}
FullFormNode totalExpression()#Start:{}
{

LOOKAHEAD(1)
	<QUESTIONMARK> ( symbolExpression() 
					|literalString()   )	
|	
	<QUESTIONMARK2> ( symbolExpression() 
					| literalString()   )	

|   ([syntaxExpression()] (<EOL>|<EOF>) )
	{jjtThis.setHead("START");}

	{	return (FullFormNode)jjtree.peekNode();}
}

void syntaxExpression() :{}
{
	level300()
}

void False(): {} {
	<FALSE>
	
}


void looserPrefix300():
{}
{
	False()
}

//Start of automatic level creation

/*
 * Stub Function for flat operator with possible postfix
 * (build to accomodate behavior of ; (CompoundExpression) 
 * a;b  --> CompoundExpression[a, b]
 * a;b; --> CompoundExpression[a, b, Null]
 * a;;b; --> CompoundExpression[a, Null, b, Null]
 */
 
void level300() :{}
{
	level299()	
	[LOOKAHEAD(1) postfix300() ]
}

void postfix300():{}
{
(	
	 	(<CompoundExpression>	{jjtThis.setValue("Null"); })#MyID	
		[LOOKAHEAD(1) {jjtree.popNode();}  term300()	]				
	 		
	{jjtThis.setHead("CompoundExpression");}

)+ #FullForm(jjtree.nodeArity()+1)
	
[LOOKAHEAD(1)	tightercheck299()]

}

void term300():{}
{			

(	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level299()
)								
}

void tightercheck300() : {} {
(
		  postfix300()
		| tightercheck299()
)									
}




//Stub Function for the Set-related operators

void level299():{}
{
	
	level298() 			
	[LOOKAHEAD(1)  postfix299()]
	
}

void postfix299():{}
{
	(
	    {jjtThis.setHeadLocation(-1);} //This means last (python style)
		level299Helper()		
	)#FullForm(jjtree.nodeArity()+1)										
}

void level299Helper():{
}{
(
	(	
		level299Tag() 			
		level299Setter("Tag")
	)
	|	level299Setter("")
	|	level299UpSetter()
)																	
}

void level299Setter(String tag)#MyID(0):{}
{ 
	level299Set() 			{jjtThis.setValue(tag+"Set");}		
|	level299SetDelayed() 	{jjtThis.setValue(tag+"SetDelayed");}		
|	level299Unset() 		{jjtThis.setValue(tag+"Unset");}		
}

void level299UpSetter()#MyID(0):{}{ 

	level299UpSet() 		{jjtThis.setValue("UpSet");}
|	level299UpSetDelayed() 	{jjtThis.setValue("UpSetDelayed");}
											
}
			
void level299Tag() :{}{
	<Tag>		
	tagterm299()				
}

void level299Set() :{}{
	<Set>		
	term299()							
}

void level299SetDelayed() : {}{
	<SetDelayed>		
	term299()					
}

void level299UpSet(): {}{
	<UpSet>  
	term299()						
}

void level299UpSetDelayed() : {}{
	<UpSetDelayed>			
	term299()							
}


void term299(): {}{
	(
		looserPrefix300()
	|	level298()
	)
	[LOOKAHEAD(1) tightercheck299()]	//this makes it right assoc.						
}

void tagterm299(): {}{
		level298()
}

void level299Unset() :{}{
	<Unset>		
}

void tightercheck299() : {} 
{
		  postfix299()
		| tightercheck298()		
}



//Stub function for postApply a//b ==> b[a]   a//b//c ==> c[b[a]]

void level298() : {}
{
	level297()
	
	[ LOOKAHEAD(1) postfix298()	]
}

void postfix298(): {}
{
		<SlashSlash>				
				
		term298()
		//If found token, look for tighter post tokens.		
		[LOOKAHEAD(1) tightercheck298()]
}


void term298()#FullForm(2):{
jjtThis.setHeadLocation(1);
}{
	 looserPrefix300()		
	| level297() 			
}

void tightercheck298() : {} {

		   postfix298()
		|  tightercheck297()

}



//Stub Function for flat operator

void level297() : {}
{
	level296()  	
	[ 	LOOKAHEAD(1)
		postfix297() 
	]												}

void postfix297()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("Colon");
}{
	(LOOKAHEAD(1)
		<Colon>							
		term297()
	)+
	(LOOKAHEAD(1)
	 tightercheck296())*	
}

void term297():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level296()
}

void tightercheck297() : {} {

		  postfix297()
		| tightercheck296()
}



//Stub function for postfix unary operations

void level296():
{}
{
	  level295()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix296()
	  ]			
														
}

void postfix296():
{} 
{
	({jjtThis.setHead("Function");}
		<Function> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck296()
	)*		
}

void tightercheck296() : {} {
(
		  postfix296()
		| tightercheck295()
)												}



//Stub Function for right-associative operators

void level295():{}
{
	level294()  	
	[ 	LOOKAHEAD(1)
		postfix295() 
		[	LOOKAHEAD(1)
			tightercheck295()
		]
	]
}

void postfix295() :{}{
	(	
		{jjtThis.setHead("DivideBy");}
		<DivideBy>
		term295()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix295()
	]
}

void term295():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level294()
}

void tightercheck295(): {} {
		LOOKAHEAD(1)
		  postfix295()
		| tightercheck294()
}


//Stub Function for right-associative operators

void level294():{}
{
	level293()  	
	[ 	LOOKAHEAD(1)
		postfix294() 
		[	LOOKAHEAD(1)
			tightercheck294()
		]
	]
}

void postfix294() :{}{
	(	
		{jjtThis.setHead("TimesBy");}
		<TimesBy>
		term294()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix294()
	]
}

void term294():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level293()
}

void tightercheck294(): {} {
		LOOKAHEAD(1)
		  postfix294()
		| tightercheck293()
}


//Stub Function for right-associative operators

void level293():{}
{
	level292()  	
	[ 	LOOKAHEAD(1)
		postfix293() 
		[	LOOKAHEAD(1)
			tightercheck293()
		]
	]
}

void postfix293() :{}{
	(	
		{jjtThis.setHead("SubtractFrom");}
		<SubtractFrom>
		term293()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix293()
	]
}

void term293():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level292()
}

void tightercheck293(): {} {
		LOOKAHEAD(1)
		  postfix293()
		| tightercheck292()
}


//Stub Function for right-associative operators

void level292():{}
{
	level291()  	
	[ 	LOOKAHEAD(1)
		postfix292() 
		[	LOOKAHEAD(1)
			tightercheck292()
		]
	]
}

void postfix292() :{}{
	(	
		{jjtThis.setHead("AddTo");}
		<AddTo>
		term292()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix292()
	]
}

void term292():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level291()
}

void tightercheck292(): {} {
		LOOKAHEAD(1)
		  postfix292()
		| tightercheck291()
}


//Stub Function for LEFT associative operator

void level291():
{}
{
	level290()  	
	[ 	LOOKAHEAD(1)
		postfix291() 
	]
}



void postfix291():{}
{
	<ReplaceRepeated>
	term291()				
	[	LOOKAHEAD(1) 
		tightercheck291()
	]		
}


void term291()#FullForm(2):
{
	jjtThis.setHead("ReplaceRepeated");
}
{			
		  looserPrefix300()
	|	  level290()
}

void tightercheck291() : {} {

		  postfix291()
		| tightercheck290()
}


//Stub Function for LEFT associative operator

void level290():
{}
{
	level289()  	
	[ 	LOOKAHEAD(1)
		postfix290() 
	]
}



void postfix290():{}
{
	<ReplaceAll>
	term290()				
	[	LOOKAHEAD(1) 
		tightercheck290()
	]		
}


void term290()#FullForm(2):
{
	jjtThis.setHead("ReplaceAll");
}
{			
		  looserPrefix300()
	|	  level289()
}

void tightercheck290() : {} {

		  postfix290()
		| tightercheck289()
}


//Stub Function for right-associative operators

void level289():{}
{
	level288()  	
	[ 	LOOKAHEAD(1)
		postfix289() 
		[	LOOKAHEAD(1)
			tightercheck289()
		]
	]
}

void postfix289() :{}{
	(	
		{jjtThis.setHead("RuleDelayed");}
		<RuleDelayed>
		term289()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix289()
	]
}

void term289():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level288()
}

void tightercheck289(): {} {
		LOOKAHEAD(1)
		  postfix289()
		| tightercheck288()
}


//Stub Function for right-associative operators

void level288():{}
{
	level287()  	
	[ 	LOOKAHEAD(1)
		postfix288() 
		[	LOOKAHEAD(1)
			tightercheck288()
		]
	]
}

void postfix288() :{}{
	(	
		{jjtThis.setHead("Rule");}
		<Rule>
		term288()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix288()
	]
}

void term288():{} {			
	LOOKAHEAD(1)
		  looserPrefix300()
	|	  level287()
}

void tightercheck288(): {} {
		LOOKAHEAD(1)
		  postfix288()
		| tightercheck287()
}


//Stub Function for LEFT associative operator

void level287():
{}
{
	level286()  	
	[ 	LOOKAHEAD(1)
		postfix287() 
	]
}



void postfix287():{}
{
	<Condition>
	term287()				
	[	LOOKAHEAD(1) 
		tightercheck287()
	]		
}


void term287()#FullForm(2):
{
	jjtThis.setHead("Condition");
}
{			
		  looserPrefix300()
	|	  level286()
}

void tightercheck287() : {} {

		  postfix287()
		| tightercheck286()
}


//Stub Function for flat operator

void level286() : {}
{
	level285()  	
	[ 	LOOKAHEAD(1)
		postfix286() 
	]												}

void postfix286()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("StringExpression");
}{
	(LOOKAHEAD(1)
		<StringExpression>							
		term286()
	)+
	(LOOKAHEAD(1)
	 tightercheck285())*	
}

void term286():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level285()
}

void tightercheck286() : {} {

		  postfix286()
		| tightercheck285()
}



//Stub Function for flat operator

void level285() : {}
{
	level284()  	
	[ 	LOOKAHEAD(1)
		postfix285() 
	]												}

void postfix285()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("Alternatives");
}{
	(LOOKAHEAD(1)
		<Alternatives>							
		term285()
	)+
	(LOOKAHEAD(1)
	 tightercheck284())*	
}

void term285():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level284()
}

void tightercheck285() : {} {

		  postfix285()
		| tightercheck284()
}



//Stub function for postfix unary operations

void level284():
{}
{
	  level283()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix284()
	  ]			
														
}

void postfix284():
{} 
{
	({jjtThis.setHead("RepeatedNull");}
		<RepeatedNull> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck284()
	)*		
}

void tightercheck284() : {} {
(
		  postfix284()
		| tightercheck283()
)												}



//Stub function for postfix unary operations

void level283():
{}
{
	  level282()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix283()
	  ]			
														
}

void postfix283():
{} 
{
	({jjtThis.setHead("Repeated");}
		<Repeated> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck283()
	)*		
}

void tightercheck283() : {} {
(
		  postfix283()
		| tightercheck282()
)												}



//Stub Function for flat operator

void level282() : {}
{
	level281()  	
	[ 	LOOKAHEAD(1)
		postfix282() 
	]												}

void postfix282()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("Or");
}{
	(LOOKAHEAD(1)
		<Or>							
		term282()
	)+
	(LOOKAHEAD(1)
	 tightercheck281())*	
}

void term282():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level281()
}

void tightercheck282() : {} {

		  postfix282()
		| tightercheck281()
}



//Stub Function for flat operator

void level281() : {}
{
	level280()  	
	[ 	LOOKAHEAD(1)
		postfix281() 
	]												}

void postfix281()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("And");
}{
	(LOOKAHEAD(1)
		<And>							
		term281()
	)+
	(LOOKAHEAD(1)
	 tightercheck280())*	
}

void term281():{}{			

		LOOKAHEAD(1)
		looserPrefix300()
	|	level280()
}

void tightercheck281() : {} {

		  postfix281()
		| tightercheck280()
}



//Stub Function for general PRE Unary operation

void level280():{}
{
	  prefix280()
	| level279() 
}

void prefix280()#FullForm:
{
	jjtThis.setHead("Not");
}
{
	<Not>					
	term280()	
}

void term280():
{}
{
	//here we are "protected" by our token, 
	//so we look for a looser token
	//as well as our token again
	//and the tighter terms in general

		  looserPrefix300()
	|	  level279()
}

//standard "empty" post helper.
void tightercheck280():{}
{
	tightercheck279()
}

void looserPrefix280() : {}
{
	  prefix280() 			
	| looserPrefix300()		
}




//Stub Function for flat operator

void level279() : {}
{
	level278()  	
	[ 	LOOKAHEAD(1)
		postfix279() 
	]												}

void postfix279()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("UnsameQ");
}{
	(LOOKAHEAD(1)
		<UnsameQ>							
		term279()
	)+
	(LOOKAHEAD(1)
	 tightercheck278())*	
}

void term279():{}{			

		LOOKAHEAD(1)
		looserPrefix280()
	|	level278()
}

void tightercheck279() : {} {

		  postfix279()
		| tightercheck278()
}



//Stub Function for flat operator

void level278() : {}
{
	level277()  	
	[ 	LOOKAHEAD(1)
		postfix278() 
	]												}

void postfix278()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("SameQ");
}{
	(LOOKAHEAD(1)
		<SameQ>							
		term278()
	)+
	(LOOKAHEAD(1)
	 tightercheck277())*	
}

void term278():{}{			

		LOOKAHEAD(1)
		looserPrefix280()
	|	level277()
}

void tightercheck278() : {} {

		  postfix278()
		| tightercheck277()
}



// This holds the production of inequalities.

void level277():{}
{
	level276()		
	[ 	LOOKAHEAD(1)
		postfix277() 
	]																						
}

void postfix277():{}
{
	( LOOKAHEAD(1)
		
			token277() 	
	)+#Inequality(jjtree.nodeArity()+1)										
}


void token277():{}
{
	  less277()			
	| lessEqual277()	
	| greater277()		
	| greaterEqual277()	
	| equal277()		
	| unequal277()												
}

void less277():{}
{
	(<Less>{jjtThis.setValue("Less");})#MyID
	term277()
}	

void lessEqual277():{}
{
	(<LessEqual> {jjtThis.setValue("LessEqual");})#MyID
	term277()	
}	

void greater277():{}
{
	(<Greater>{jjtThis.setValue("Greater");})#MyID
	term277()
}	

void greaterEqual277():{}
{
	(<GreaterEqual>{jjtThis.setValue("GreaterEqual");})#MyID
	term277()
}	

void equal277():{}
{
	(<Equal>{jjtThis.setValue("Equal");})#MyID
	term277()
}	

void unequal277():{}
{
	(<Unequal>{jjtThis.setValue("Unequal");})#MyID
	term277()
}	

void term277():{}
{			
	LOOKAHEAD(1)
	//since we found our token, we look for looser prefix operators
	//decorating our next term
		  looserPrefix280()
	|	  level276()		
}

void tightercheck277() : {} 
{
		  postfix277()
		| tightercheck276()
}




//Stub Function for the flat operator Plus. this is 
//special because of the need to accept Plus and minus and
// do interesting stuff with them


void level276():{}
{
	level275()  	
	[ 	LOOKAHEAD(1)
		postfix276() 
	]								
}
void postfix276() :{}
{
(
	LOOKAHEAD(1)(
	(
		(
		  (LOOKAHEAD(1) <PLUS>)+ 	
		| (LOOKAHEAD(1) <MINUS> {jjtThis.setValue(-1);}  #MyInteger   )+	
		) 
		
		term276()
	)#PlusTerm(>1)				
//	{if((jjtree.peekNode() instanceof ASTPlusTerm) &&jjtree.peekNode().jjtGetNumChildren()==1){
//		Node n=jjtree.popNode();
//		jjtree.pushNode(n.jjtGetChild(0));
//	}}
			{jjtThis.setHead("Plus");}
	)
	
)+ #FullForm(jjtree.nodeArity()+1)

[LOOKAHEAD(1) tightercheck276()]

}

void term276() :{}
{
(	
	//since we found our token, we look for looser prefix operators
	//decorating our next term
	(
	  looserPrefix280() 
	| level275()
	)

) 		
}

void tightercheck276() : {} {
(
	  postfix276()
	| tightercheck275()
)									
}



//Stub Function for flat operator

void level275() : {}
{
	level274()  	
	[ 	LOOKAHEAD(1)
		postfix275() 
	]												}

void postfix275()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("CirclePlus");
}{
	(LOOKAHEAD(1)
		<CirclePlus>							
		term275()
	)+
	(LOOKAHEAD(1)
	 tightercheck274())*	
}

void term275():{}{			

		LOOKAHEAD(1)
		looserPrefix280()
	|	level274()
}

void tightercheck275() : {} {

		  postfix275()
		| tightercheck274()
}



//Stub Function for the flat operator Times. this is 
//special because of the need to accept implicit multiply.
//the level that takes care of unary plus and minus MUST be directly
//below this level (i.e the operators must be above) so that it can skip it...


void level274():{}
{
	level273()  	
	[ 	LOOKAHEAD(1)
		postfix274() 
	]								
}

void postfix274():{}
{
	//Explicit
	(LOOKAHEAD(1)
		{jjtThis.setHead("Times");}
		(	
			(
				{jjtThis.setHead("Power");
				 jjtThis.reverseChildren();}
				 
				(
				  (  <TIMES>)						
		   		| (<DIVIDE> {jjtThis.setValue(-1);})#MyInteger()						
				)
				explicitTerm274()				

			)#FullForm(>1)
			|
			//Implicit
			implicitTerm274()
		)
	)+#FullForm(jjtree.nodeArity()+1 )
		
	[LOOKAHEAD(1) 	tightercheck273()]	
}


void explicitTerm274():{}
{			
	(	LOOKAHEAD(1)
		  looserPrefix280()
		| level273()
	)			
}

void implicitTerm274():{}
{			
		//No token, nothing to "protect" looser tokens.
		//allow only if no plus, i.e skip over next level

	level272() 
}

void tightercheck274() : {} 
{
	(	LOOKAHEAD(1)
		  postfix274()
		| tightercheck273()
	)			
}





//Stub Function for PRE PLUS and MINUS Unary operation

//Nota Bene: This level must occur directly under the one for multiply since 
//we allow for implicit multiply and the only prefix operators that cannot
//partake in that are + and -.


void level273():{}{
(	  prefix273()
	| level272() 
)		
}


void prefix273() #PlusTerm(>1):{} {
(
  	(<PLUS>)+	
| 	(<MINUS>  	{jjtThis.setValue(-1);}  #MyInteger   )+ 
)

	term273()

}
void term273() :{} {

	( looserPrefix280() 
	| level272()
	)
}

//standard "empty" post helper.
void tightercheck273():{}
{
	tightercheck272()
}


void looserPrefix273() : {}
{
	  prefix273() 				
	| looserPrefix280()	
}




//Stub Function for right-associative operators

void level272():{}
{
	level271()  	
	[ 	LOOKAHEAD(1)
		postfix272() 
		[	LOOKAHEAD(1)
			tightercheck272()
		]
	]
}

void postfix272() :{}{
	(	
		{jjtThis.setHead("Power");}
		<Power>
		term272()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix272()
	]
}

void term272():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level271()
}

void tightercheck272(): {} {
		LOOKAHEAD(1)
		  postfix272()
		| tightercheck271()
}


//Stub Function for flat operator

void level271() : {}
{
	level270()  	
	[ 	LOOKAHEAD(1)
		postfix271() 
	]												}

void postfix271()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("StringJoin");
}{
	(LOOKAHEAD(1)
		<StringJoin>							
		term271()
	)+
	(LOOKAHEAD(1)
	 tightercheck270())*	
}

void term271():{}{			

		LOOKAHEAD(1)
		looserPrefix273()
	|	level270()
}

void tightercheck271() : {} {

		  postfix271()
		| tightercheck270()
}



//Stub Function for the pattern creation (Using ':')

void level270():{}
{
	
		level269()
		
		[LOOKAHEAD(1) postfix270()]
									
}
void postfix270():{}
{
	(LOOKAHEAD(1) optionalHelper270())+ #Optional(jjtree.nodeArity()+1)
}


void optionalHelper270():{}
{
	
	//a colon means different things depending on the Head of the previous 
	//term. We just collect the various terms in a big "Optional" Node and let
	//it chug away at it.
	(
	<Optional>
	term270()
	)


}


void term270(): {}
{
	(LOOKAHEAD(1)
	 	looserPrefix273()
	|	level269()
	)	
}


void tightercheck270() : {} 
{
(
		 tightercheck269()
		 
)										
}




//Stub function for postfix unary operations

void level269():
{}
{
	  level268()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix269()
	  ]			
														
}

void postfix269():
{} 
{
	({jjtThis.setHead("Factorial");}
		<Not> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck269()
	)*		
}

void tightercheck269() : {} {
(
		  postfix269()
		| tightercheck268()
)												}



//Stub function for postfix unary operations

void level268():
{}
{
	  level267()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix268()
	  ]			
														
}

void postfix268():
{} 
{
	({jjtThis.setHead("Factorial2");}
		<Factorial2> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck268()
	)*		
}

void tightercheck268() : {} {
(
		  postfix268()
		| tightercheck267()
)												}



//Stub Function for Deep Apply f @@@ g ==> Apply[f, g, List[1]]

void level267():{} {

	level266()  	
	[ 	LOOKAHEAD(1)
		postfix267() 
		[	LOOKAHEAD(1)
			tightercheck267()
		]
	]
}



void postfix267() :{}
{
	(	
		{jjtThis.setHead("Apply");}
		<DeepApply>
		term267()
		({jjtThis.setHead("List");} ({jjtThis.setValue("1");})#MyInteger()    )#FullForm
	)#FullForm(3)			
	
	[	LOOKAHEAD(1)
		postfix267()
	]
}

void term267():{}
{			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level266()
}


void tightercheck267(): {} {
		LOOKAHEAD(1)
		  postfix267()
		| tightercheck266()
}


//Stub Function for right-associative operators

void level266():{}
{
	level265()  	
	[ 	LOOKAHEAD(1)
		postfix266() 
		[	LOOKAHEAD(1)
			tightercheck266()
		]
	]
}

void postfix266() :{}{
	(	
		{jjtThis.setHead("Apply");}
		<Apply>
		term266()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix266()
	]
}

void term266():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level265()
}

void tightercheck266(): {} {
		LOOKAHEAD(1)
		  postfix266()
		| tightercheck265()
}


//Stub Function for right-associative operators

void level265():{}
{
	level264()  	
	[ 	LOOKAHEAD(1)
		postfix265() 
		[	LOOKAHEAD(1)
			tightercheck265()
		]
	]
}

void postfix265() :{}{
	(	
		{jjtThis.setHead("ApplyAll");}
		<ApplyAll>
		term265()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix265()
	]
}

void term265():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level264()
}

void tightercheck265(): {} {
		LOOKAHEAD(1)
		  postfix265()
		| tightercheck264()
}


//Stub Function for right-associative operators

void level264():{}
{
	level263()  	
	[ 	LOOKAHEAD(1)
		postfix264() 
		[	LOOKAHEAD(1)
			tightercheck264()
		]
	]
}

void postfix264() :{}{
	(	
		{jjtThis.setHead("Map");}
		<Map>
		term264()
	)#FullForm(2)			
	
	[	LOOKAHEAD(1)
		postfix264()
	]
}

void term264():{} {			
	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level263()
}

void tightercheck264(): {} {
		LOOKAHEAD(1)
		  postfix264()
		| tightercheck263()
}


//Stub Function for "mid-fix" operator ~ (as in a~h~b -> h[a,b])

void level263():{}
{
	level262()  				
		
	[LOOKAHEAD(1) 
		postfix263()
	]		
}

void postfix263(): {}
{
(	LOOKAHEAD(1)
	(
		{jjtThis.setHeadLocation(1);}
		<Tilde>
		term263()			
		<Tilde>
		term263()

	)	#FullForm(3)			
)+														
(		LOOKAHEAD(1) 
		 tightercheck263())*		
}

void term263():{}{			

(	LOOKAHEAD(1)
		  looserPrefix273()
	|	  level262()
)												
}


void tightercheck263() : {} {
(
		LOOKAHEAD(1)
		  postfix263()
		| tightercheck262()
)												
}





//Stub function for preApply a@b ==> a[b]  a@b@c ==> a[b[c]]
void level262() : {}
{
	level261()
	
	[ LOOKAHEAD(1) postfix262()	]
}





void postfix262(): {}
{
		(
		<At>				
		term262()
		)						
		
		(LOOKAHEAD(1) tightercheck262())*
														
}


void term262()#FullForm(2):
{
	jjtThis.setHeadLocation(0);
}
{
	( 
	 looserPrefix273()		
	| level261() )	

	[LOOKAHEAD(1) postfix262()]

}

void tightercheck262() : {} {
(
		  postfix262()
		| tightercheck261()
)												
}



//Stub Function for general PRE Unary operation

void level261():{}
{
	  prefix261()
	| level260() 
}

void prefix261()#FullForm:
{
	jjtThis.setHead("PreDecrement");
}
{
	<PreDecrement>					
	term261()	
}

void term261():
{}
{
	//here we are "protected" by our token, 
	//so we look for a looser token
	//as well as our token again
	//and the tighter terms in general

		  looserPrefix273()
	|	  level260()
}

//standard "empty" post helper.
void tightercheck261():{}
{
	tightercheck260()
}

void looserPrefix261() : {}
{
	  prefix261() 			
	| looserPrefix273()		
}




//Stub Function for general PRE Unary operation

void level260():{}
{
	  prefix260()
	| level259() 
}

void prefix260()#FullForm:
{
	jjtThis.setHead("PreIncrement");
}
{
	<PreIncrement>					
	term260()	
}

void term260():
{}
{
	//here we are "protected" by our token, 
	//so we look for a looser token
	//as well as our token again
	//and the tighter terms in general

		  looserPrefix261()
	|	  level259()
}

//standard "empty" post helper.
void tightercheck260():{}
{
	tightercheck259()
}

void looserPrefix260() : {}
{
	  prefix260() 			
	| looserPrefix261()		
}




//Stub function for postfix unary operations

void level259():
{}
{
	  level258()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix259()
	  ]			
														
}

void postfix259():
{} 
{
	({jjtThis.setHead("Decrement");}
		<PreDecrement> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck259()
	)*		
}

void tightercheck259() : {} {
(
		  postfix259()
		| tightercheck258()
)												}



//Stub function for postfix unary operations

void level258():
{}
{
	  level257()
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [
	  	LOOKAHEAD(1) 
	  	postfix258()
	  ]			
														
}

void postfix258():
{} 
{
	({jjtThis.setHead("Increment");}
		<PreIncrement> ) #FullForm(1) 									

	(
		LOOKAHEAD(1) 
			tightercheck258()
	)*		
}

void tightercheck258() : {} {
(
		  postfix258()
		| tightercheck257()
)												}



//Stub Function for flat operator

void level257() : {}
{
	level256()  	
	[ 	LOOKAHEAD(1)
		postfix257() 
	]												}

void postfix257()#FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHead("MessageName");
}{
	(LOOKAHEAD(1)
		<MessageName>							
		term257()
	)+
	(LOOKAHEAD(1)
	 tightercheck256())*	
}

void term257():{}{			

		LOOKAHEAD(1)
		looserPrefix260()
	|	level256()
}

void tightercheck257() : {} {

		  postfix257()
		| tightercheck256()
}





//End of automatic level creation


void tightercheck256(): {} {
	tightercheckFullForm()
}

void level256() :{}
{
	fullFormExpression()
}

//A "Pass-Through" PrefixHelper to connect lower layers
void prefixBase(): {} 
{
	// no token, so just look for looser prefix
	 looserPrefix260() 	
}

void fullFormExpression() :{}
{
	  partExpression()					
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [	LOOKAHEAD(1) postfixFullForm()]			
}

void postfixFullForm(): {}
{
		fullFormTail()		
		(	LOOKAHEAD(1) 
			tightercheckFullForm()
		)*	
}

void fullFormTail() #FullForm(jjtree.nodeArity()+1) :
{
	jjtThis.setHeadLocation(0);
}
{
	<LBRACKET> 	
	[
		syntaxExpression() 					
		( 
		  	<COMMA>
	  		syntaxExpression()						
		)* 
	]
	<RBRACKET> 							
}

void tightercheckFullForm() : {} {
	postfixFullForm()
|	tightercheckPart()
}

void partExpression() : {}
{
	  patternTestExpression()				
//there's a "hanging Token" problem here since it's a
//postfix operator...Hence the lookahead(1)
	  [LOOKAHEAD(1) postfixPart()]			
}

void postfixPart(): {}
{
		partTail()
		(LOOKAHEAD(1) tightercheckPart())*		
}

void partTail()#FullForm(jjtree.nodeArity()+1) :{
	jjtThis.setHead("Part");
}{
	<TwoLBRACKETS> 				
	
	syntaxExpression()					 					
	( 
		<COMMA>
	   	syntaxExpression()						
	)*			
	<RBRACKET><RBRACKET> 							
}

void tightercheckPart() : {} {
		  postfixPart()
		| tightercheckPatternTest()								
}

//Function for a PatternTest expression a?b => PatternTest[a,b] 

void patternTestExpression() :{}{

	(LOOKAHEAD(2,(symbolExpression()blankExpression())|blankExpression(),
                 {getToken(1).kind!=SYMBOL||getToken(2).specialToken==null})
	 patternExpression()  	
	|atomicExpression() )

	[ 	LOOKAHEAD(1)
		postfixPatternTest() 
	]
}

void postfixPatternTest() #FullForm(2) :
{
	jjtThis.setHead("PatternTest");
}{
	<QUESTIONMARK> 								
	termPatternTest()	
}

void termPatternTest():{}
{				
//		prefixBase()
		LOOKAHEAD(2,(symbolExpression()blankExpression())|blankExpression(),
                 {getToken(1).kind!=SYMBOL||getToken(2).specialToken==null})
		patternExpression()
	| 	atomicExpression()
}

void tightercheckPatternTest() : {} {
		  postfixPatternTest()	
}

void atomicExpression() :{}
{
	outExpression()					
|	slotExpression()
	/*
	 * Since pattern expression begins with a raw expression, 
	 * we need a lookahead of 2.
	 *
	 * a Null special token indicates that it is a whitespace, since that is the
	 * only kind of specialToken that we currently have....
	 */			
|	nonNegativeInteger()			
		/*
		 * FIXME not yet implemented
		 */
//	|	a = nonNegativeReal()
	    /*
	     * Make sure you read the comment about negative integers, above.
	     * Quite likely the same will apply here.
	     */

|   literalString() 
|   parenthesisedExpression() 
|	bracedExpression()			
|   symbolExpression()
}



void outExpression() :
{
	ASTMyInteger a = new ASTMyInteger(JJTMYINTEGER);
	a.setValue(-1);
	Integer number=-1;		
}{
	
	/*
	 * Here we catch Out expressions.
	 *
	 * % should produce Out[]
	 * %%% or generally, n consecutive percent signs), should produce Out[-n]
	 * %m should produce Out[m] (only for positive integers)
	 */
	
	( {jjtThis.setHead("Out");}<PERCENT>		
	/*
	 * At this point there's a choice; either multiple percent signs, or a number
	 */
	[LOOKAHEAD(1) 
		( 		
			( LOOKAHEAD(1)<PERCENT> 			{ number--; jjtThis.setValue(number);} 
			)+ #MyInteger  								
		|		
			nonNegativeInteger()				
		) 
	]	
	) #FullForm		
}

void slotExpression() :
{
	ASTMyInteger a=new ASTMyInteger(JJTMYINTEGER);
	a.setValue(1); 
	Node n=(Node)a;
}{
	/*
	 * Here we match things like #, ##, #n and ##n; these occur in pure functions.
	 */
	(
		(<HASH> 								{jjtThis.setHead("Slot");}
		[LOOKAHEAD(1)  (nonNegativeInteger() 	{n=jjtree.popNode(); })]
		)#FullForm  	 		

	|	(<HASHHASH> 							{jjtThis.setHead("SlotSequence");}
		[LOOKAHEAD(1) nonNegativeInteger() 		{n=jjtree.popNode(); }]
		)#FullForm  	 

	)		 									{jjtree.peekNode().jjtAddChild(n,0);}
}

/*
 *
 * patternExpression is complicated!
 * 
 * The necessary part is the blankExpression in the middle. This matches one of _, __ and ___
 * Before the blank, we can optionally have a symbol (not an arbitrary expression!).
 *		(this symbol names the pattern)
 * After the blank there are two alternatives:
 *		i) either a . (which means the pattern is optional)
 *		ii) or a symbol, prescribing the head of whatever this blank can match
 *				(this can only be a symbol;
 *					try "_f[x] // FullForm" or "_(f[x]) // FullForm" if you doubt this!)
 *
 * The java code at the bottom builds the appropriate strings.
 */

/* Use 
		LOOKAHEAD(2,(symbolExpression()blankExpression())|blankExpression(),
                 {getToken(1).kind!=SYMBOL||getToken.specialToken==null})

   before calling this production.
*/
void patternExpression():
{
boolean typedBlank=false;
}
{
	
(	(	{jjtThis.setHead("Pattern");}	
		symbolExpression() 				
		typedBlank=blankExpression()	   		
	)	#FullForm
	|
		typedBlank=blankExpression()				
)
[	LOOKAHEAD(1,<PERIOD>,{!typedBlank})
		({jjtThis.setHead("Optional");}	<PERIOD>)#FullForm(1)
]

}


boolean blankExpression():
{
String blankType;
boolean typed=false;
}
{
	//here we want to find either a typed blank "_a" or an untyped blank  "_"
	//we return true if the blank is typed, otherwise false.
	
(
	( 
		blankType=blank() 			{jjtThis.setHead(blankType);} 
	)	
	[	LOOKAHEAD(1,symbolExpression(),{getToken(1).specialToken==null})	
			symbolExpression()    	{typed=true;}
	]

)#FullForm
{return typed;}
}


String blank() :
{
String blankType;
}
{
	/*
	 *	Pretty self explanatory!
	 */

	(
				<BLANK>						{blankType="Blank";}
		|		<BLANKSEQUENCE>				{blankType="BlankSequence";}
		|		<BLANKNULLSEQUENCE>			{blankType="BlankNullSequence";}
	)	{return blankType;}


}


void rawExpression() : {}
{
		/*
		 * Negative integers are dealt with higher up!
		 * In particular, there's a hack in the level for Plus and Minus which produces negative integers properly
		 * 
		 * You should look at flatPlusStub.txt and prePlusStub.txt (at least in REV 268) to work out what's
		 * going on!
		 *
		 * In the current implementation (REV 268), it appears that negative Integers are never actually
		 * caught here they are dealt with by the code in prePlusStub.txt
		 */
		nonNegativeInteger()			
		/*
		 * FIXME not yet implemented
		 */
//	|	a = nonNegativeReal()
	    /*
	     * Make sure you read the comment about negative integers, above.
	     * Quite likely the same will apply here.
	     */

	|   literalString() 
	|   symbolExpression()  			
}

void parenthesisedExpression():{}
{
		<LPAREN> syntaxExpression() <RPAREN>		
}

void bracedExpression() #FullForm: 
{
	jjtThis.setHead("List");
}
{
		<LBRACE>										
		(
			syntaxExpression()				
			(
				<COMMA>
				syntaxExpression()			
			)*
		)?
		<RBRACE>										
}

void nonNegativeInteger() #MyInteger:
{
	Token t;
	String number;
}
{
		(t = <NONNEGATIVEINTEGER>			{ number = t.toString(); 
											  while(number.charAt(0)=='0' && number.length()>1)
											  		number = number.substring(1);
											  jjtThis.setValue(number);
											})
											{}
}

/*
 * FIXME
 */ 
void nonNegativeReal() :{}
{
	<FALSE>						
}

void literalString() #MyString :{
	Token t;
}{
	(t = <STRING_LITERAL>		
								{ jjtThis.setValue(t.image); }
	)							{}
}

void symbolExpression() #MyID:{
	Token t;
	String ret;
}{
	(t = <SYMBOL>	
					{ 	ret = t.toString();
						if (ret.charAt(0)=='`') 
							ret = ret.substring(1); 
						jjtThis.setValue(ret);
					}
	)				{}
}